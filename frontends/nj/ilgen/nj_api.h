/*******************************************************************************
 * Copyright (c) 2000, 2018 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution and is available at http://eclipse.org/legal/epl-2.0
 * or the Apache License, Version 2.0 which accompanies this distribution
 * and is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License, v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception [1] and GNU General Public
 * License, version 2 with the OpenJDK Assembly Exception [2].
 *
 * [1] https://www.gnu.org/software/classpath/license.html
 * [2] http://openjdk.java.net/legal/assembly-exception.html
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH
 *Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
 *******************************************************************************/
#ifndef JIT_api_h
#define JIT_api_h

#include <stdint.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * The Jit Context defines a container for the Jit machinery and
 * also acts as the repository of the compiled functions. The Jit
 * Context must be kept alive as long as any functions within it are
 * needed. Deleting the Jit Context may delete all compiled
 * functions managed by the context (this happens if there are
 * no more alive JIT contexts).
 *
 * Note that at present OMR JIT maintains a global
 * Code Cache behind the scenes. Hence compiled code may live on
 * longer than expected although once the JIT Context is dead
 * you may not be able to access the compiled code held in
 * the code cache.
 *
 * In future my hope is to make the global Code Cache local
 * to the JIT Context.
 */
typedef struct JIT_Context* JIT_ContextRef;

/**
 * Creates a Jit Context.
 * Will Initialize the OMR JIT engine if not already initalized
 */
extern JIT_ContextRef JIT_CreateContext();

/**
 * Destroys the Jit Context. Note that all compiled functions
 * managed by this context may die at this point.
 * JIT Contexts are counted such that if this is the last
 * live context then the OMR JIT will be shutdown at this
 * point.
 */
extern void JIT_DestroyContext(JIT_ContextRef);

/*
 * OMR Types
 */
enum JIT_Type {
    JIT_NoType = 0,
    JIT_Int8,
    JIT_Int16,
    JIT_Int32,
    JIT_Int64,
    JIT_Float,
    JIT_Double,
    JIT_Address, /* pointer */
    JIT_VectorInt8,
    JIT_VectorInt16,
    JIT_VectorInt32,
    JIT_VectorInt64,
    JIT_VectorFloat,
    JIT_VectorDouble,
    JIT_Aggregate, /* A byte array is of this type for example */
};
typedef enum JIT_Type JIT_Type;

/**
 * The JIT ILBuilder callback must be implemented by the
 * user. All of the IL generation is meant to happen here.
 * Note that during compilation certain thread local variables are
 * used; including a Compiler object which is stored in the
 * thread local context.
 *
 * Userdata is whatever was given to JIT_CreateFunctionBuilder.
 */
typedef struct JIT_ILInjector* JIT_ILInjectorRef;
typedef bool (*JIT_ILBuilder)(JIT_ILInjectorRef, void* userdata);

/**
 * A Function Builder is used to generate code for a single
 * C function equivalent. Once the code is generated by invoking
 * JIT_Compile() on the builder, the builder itself can be destroyed as the
 * compiled function lives on in the associated Jit Context.
 */
typedef struct JIT_FunctionBuilder* JIT_FunctionBuilderRef;

/**
 * Creates a new function builder object. The builder is used to construct the
 * code that will go into one function. Note that this function only
 * creates the function type - the actual IL generation happens
 * when JIT_Compile() is called. After the function is
 * compiled the builder object can be thrown away - the compiled function
 * will live as long as the owning Jit Context lives.
 */
extern JIT_FunctionBuilderRef JIT_CreateFunctionBuilder(JIT_ContextRef context, const char* name, JIT_Type return_type,
    int param_count, const JIT_Type* parameters, JIT_ILBuilder ilbuilder, void* userdata);

/**
 * Register an external function (not managed by JIT). Note that
 * any exsiting function regsitered by the same name will be
 * over-written.
 */
extern void JIT_RegisterFunction(JIT_ContextRef context, const char* name, enum JIT_Type return_type, int param_count,
    const JIT_Type* parameters, void* functionptr);

/**
 * Get a registered function by name. This will return
 * NULL if no function exists by that name.
 */
void* JIT_GetFunction(JIT_ContextRef ctx, const char* name);

/**
 * Destroys the function builder object. Note that this will not delete the
 * compiled function created using this builder - as the compiled function lives
 * in the owning Jit Context.
 */
extern void JIT_DestroyFunctionBuilder(JIT_FunctionBuilderRef);

/*
IMPORTANT Notes:

The IL is a DAG rather than linear IR.

The IL is arranged in basic blocks of type JIT_BlockRef (Block). The
instructions are represented by JIT_NodeRef (Node) objects which are DAG nodes.
The Nodes are anchored in JIT_TreeTopRefs (TreeTops). The TreeTops are used to
determine program order.

Separately a Control Flow Graph is maintained which links the blocks in a graph.
The user must set up the graph edges depending on control flow. JIT_BlockRefs
are of type JIT_CFGNodeRef. Some api calls will automatically add the
appropriate edge. See usage notes below for when you need to add your own.

The IL requires that for a Node to be accessed in a Block other than where
it was created, the Node must have be stored in the block that created it.
*/

typedef struct JIT_Node* JIT_NodeRef;
typedef struct JIT_TreeTop* JIT_TreeTopRef;
typedef struct JIT_Block* JIT_BlockRef;
typedef struct JIT_CFGNode* JIT_CFGNodeRef; // Note that Blocks are CFGNodes
typedef struct JIT_Symbol* JIT_SymbolRef;

/**
 * Generate IL and compile the function. To generate IL the user supplied
 * JIT_ILBuilder callback will be invoked. If that succeeds then the
 * function will be compiled.
 *
 * opt_level controls optimizations.
 * 0 = no opt
 * 1 = warm
 * 2 = hot
 *
 * This function returns pointer to compiled code on success
 * Or else a NULL is returned.
 */
extern void* JIT_Compile(JIT_FunctionBuilderRef fb, int opt_level);

/**
 * Allocates given number of blocks, and leaves the current block pointer
 * at 0. The CFG starting edge is made to point to Node 0.
 */
extern void JIT_CreateBlocks(JIT_ILInjectorRef ilinjector, int32_t num);

/**
 * Makes the given block number the current block. This must be done
 * prior to generating any IL.
 */
extern void JIT_SetCurrentBlock(JIT_ILInjectorRef ilinjector, int32_t b);

/**
 * Gets the current block
 */
extern JIT_BlockRef JIT_GetCurrentBlock(JIT_ILInjectorRef ilinjector);

/**
 * Gets the specified block
 */
extern JIT_BlockRef JIT_GetBlock(JIT_ILInjectorRef ilinjector, int32_t b);

/**
 * Create various constants
 */
extern JIT_NodeRef JIT_ConstInt32(int32_t i);
extern JIT_NodeRef JIT_ConstInt64(int64_t i);
extern JIT_NodeRef JIT_ConstInt16(int16_t i);
extern JIT_NodeRef JIT_ConstInt8(int8_t i);
extern JIT_NodeRef JIT_ConstFloat(float value);
extern JIT_NodeRef JIT_ConstDouble(double value);
extern JIT_NodeRef JIT_ConstAddress(void* value);
extern JIT_NodeRef JIT_ConstUInt32(uint32_t i);
extern JIT_NodeRef JIT_ConstUInt64(uint64_t i);
extern JIT_NodeRef JIT_ConstUInt8(uint8_t i);
extern JIT_NodeRef JIT_ZeroValue(JIT_ILInjectorRef ilinjector, JIT_Type type);

/**
 * Gets the Node's type
 */
extern JIT_Type JIT_GetNodeType(JIT_NodeRef node);

/**
 * Node opcodes - See the JIT_CreateNode*() family of
 * functions. Note that some opcodes need 1 or more child nodes,
 * this is indicated in the comment that follows each enum
 * value.
 */
enum JIT_NodeOpCode {
    OP_BadILOp = 0, // illegal op hopefully help with uninitialised nodes
    OP_aconst, // load address constant (zero value means NULL)
    OP_iconst, // load integer constant (32-bit signed 2's complement)
    OP_lconst, // load long integer constant (64-bit signed 2's complement)
    OP_fconst, // load float constant (32-bit ieee fp)
    OP_dconst, // load double constant (64-bit ieee fp)
    OP_bconst, // load byte integer constant (8-bit signed 2's complement)
    OP_sconst, // load short integer constant (16-bit signed 2's complement)
    OP_iload, // load integer
    OP_fload, // load float
    OP_dload, // load double
    OP_aload, // load address
    OP_bload, // load byte
    OP_sload, // load short integer
    OP_lload, // load long integer
    // Read barrier is used to represent loads with side effects like check for GC, debugging etc.
    // It is the same as the corresponding load except that it needs to be anchored under a
    // treetop. The children and symbol of a read barrier are the same as the corresponding load.
    OP_irdbar, // read barrier for load integer
    OP_frdbar, // read barrier for load float
    OP_drdbar, // read barrier for load double
    OP_ardbar, // read barrier for load address
    OP_brdbar, // read barrier for load byte
    OP_srdbar, // load short integer
    OP_lrdbar, // load long integer
    OP_iloadi, // load indirect integer
    OP_floadi, // load indirect float
    OP_dloadi, // load indirect double
    OP_aloadi, // load indirect address
    OP_bloadi, // load indirect byte
    OP_sloadi, // load indirect short integer
    OP_lloadi, // load indirect long integer
    OP_irdbari, // read barrier for load indirect integer
    OP_frdbari, // read barrier for load indirect float
    OP_drdbari, // read barrier for load indirect double
    OP_ardbari, // read barrier for load indirect address
    OP_brdbari, // read barrier for load indirect byte
    OP_srdbari, // read barrier for load indirect short integer
    OP_lrdbari, // read barrier for load indirect long integer
    OP_istore, // store integer
    OP_lstore, // store long integer
    OP_fstore, // store float
    OP_dstore, // store double
    OP_astore, // store address
    OP_bstore, // store byte
    OP_sstore, // store short integer
               // direct write barrier represent both the write and side effects of
               // the write like checks for GC, debugging etc.
               //
               // In case of GC checks, write barrier checks for new space in old
               // space reference store. The first child is the value as in astore.
               // The second child is the address of the object that must be checked
               // for old space the symbol reference holds addresses, flags and offsets
               // as in astore
    OP_iwrtbar, // write barrier for store direct integer
    OP_lwrtbar, // write barrier for store direct long integer
    OP_fwrtbar, // write barrier for store direct float
    OP_dwrtbar, // write barrier for store direct double
    OP_awrtbar, // write barrier for store direct address
    OP_bwrtbar, // write barrier for store direct byte
    OP_swrtbar, // write barrier for store direct short integer

    OP_lstorei, // store indirect long integer           (child1 a, child2 l)
    OP_fstorei, // store indirect float                  (child1 a, child2 f)
    OP_dstorei, // store indirect double                 (child1 a, child2 d)
    OP_astorei, // store indirect address                (child1 a dest, child2 a
                // value)
    OP_bstorei, // store indirect byte                   (child1 a, child2 b)
    OP_sstorei, // store indirect short integer          (child1 a, child2 s)
    OP_istorei, // store indirect integer                (child1 a, child2 i)
                // indirect write barrier represent both the write and side effects of
                // the write like checks for GC, debugging etc.
                //
                // In case of GC checks, indirect write barrier store checks for new space
                // in old space reference store.
                // The first two children are as in astorei.  The third child is address
                // of the beginning of the destination object.  For putfield this will often
                // be the same as the first child (when the offset is on the symbol reference.
                // But for array references, children 1 and 3 will be quite different although
                // child 1's subtree will contain a reference to child 3's subtree
    OP_lwrtbari, // write barrier for store indirect long integer
    OP_fwrtbari, // write barrier for store indirect float
    OP_dwrtbari, // write barrier for store indirect double
    OP_awrtbari, // write barrier for store indirect address
    OP_bwrtbari, // write barrier for store indirect byte
    OP_swrtbari, // write barrier for store indirect short integer
    OP_iwrtbari, // write barrier for store indirect integer
    OP_Goto, // goto label address
    OP_ireturn, // return an integer
    OP_lreturn, // return a long integer
    OP_freturn, // return a float
    OP_dreturn, // return a double
    OP_areturn, // return an address
    OP_Return, // void return
    OP_asynccheck, // GC point
    OP_athrow, // throw an exception
    OP_icall, // direct call returning integer
    OP_lcall, // direct call returning long integer
    OP_fcall, // direct call returning float
    OP_dcall, // direct call returning double
    OP_acall, // direct call returning reference
    OP_call, // direct call returning void
    OP_iadd, // add 2 integers
    OP_ladd, // add 2 long integers
    OP_fadd, // add 2 floats
    OP_dadd, // add 2 doubles
    OP_badd, // add 2 bytes
    OP_sadd, // add 2 short integers
    OP_isub, // subtract 2 integers                (child1 - child2)
    OP_lsub, // subtract 2 long integers           (child1 - child2)
    OP_fsub, // subtract 2 floats                  (child1 - child2)
    OP_dsub, // subtract 2 doubles                 (child1 - child2)
    OP_bsub, // subtract 2 bytes                   (child1 - child2)
    OP_ssub, // subtract 2 short integers          (child1 - child2)
    OP_asub, // subtract 2 addresses (child1 - child2)
    OP_imul, // multiply 2 integers
    OP_lmul, // multiply 2 signed or unsigned long integers
    OP_fmul, // multiply 2 floats
    OP_dmul, // multiply 2 doubles
    OP_bmul, // multiply 2 bytes
    OP_smul, // multiply 2 short integers
    OP_iumul, // multiply 2 unsigned integers
    OP_idiv, // divide 2 integers                (child1 / child2)
    OP_ldiv, // divide 2 long integers           (child1 / child2)
    OP_fdiv, // divide 2 floats                  (child1 / child2)
    OP_ddiv, // divide 2 doubles                 (child1 / child2)
    OP_bdiv, // divide 2 bytes                   (child1 / child2)
    OP_sdiv, // divide 2 short integers          (child1 / child2)
    OP_iudiv, // divide 2 unsigned integers       (child1 / child2)
    OP_ludiv, // divide 2 unsigned long integers  (child1 / child2)
    OP_irem, // remainder of 2 integers                (child1 % child2)
    OP_lrem, // remainder of 2 long integers           (child1 % child2)
    OP_frem, // remainder of 2 floats                  (child1 % child2)
    OP_drem, // remainder of 2 doubles                 (child1 % child2)
    OP_brem, // remainder of 2 bytes                   (child1 % child2)
    OP_srem, // remainder of 2 short integers          (child1 % child2)
    OP_iurem, // remainder of 2 unsigned integers       (child1 % child2)
    OP_ineg, // negate an integer
    OP_lneg, // negate a long integer
    OP_fneg, // negate a float
    OP_dneg, // negate a double
    OP_bneg, // negate a bytes
    OP_sneg, // negate a short integer
    OP_iabs, // absolute value of integer
    OP_labs, // absolute value of long
    OP_fabs, // absolute value of float
    OP_dabs, // absolute value of double
    OP_ishl, // shift integer left                (child1 << child2)
    OP_lshl, // shift long integer left           (child1 << child2)
    OP_bshl, // shift byte left                   (child1 << child2)
    OP_sshl, // shift short integer left          (child1 << child2)
    OP_ishr, // shift integer right arithmetically               (child1 >>
             // child2)
    OP_lshr, // shift long integer right arithmetically          (child1 >>
             // child2)
    OP_bshr, // shift byte right arithmetically                  (child1 >>
             // child2)
    OP_sshr, // shift short integer arithmetically               (child1 >>
             // child2)
    OP_iushr, // shift integer right logically                   (child1 >>
              // child2)
    OP_lushr, // shift long integer right logically              (child1 >>
              // child2)
    OP_bushr, // shift byte right logically                      (child1 >>
              // child2)
    OP_sushr, // shift short integer right logically             (child1 >>
              // child2)
    OP_irol, // rotate integer left
    OP_lrol, // rotate long integer left
    OP_iand, // boolean and of 2 integers
    OP_land, // boolean and of 2 long integers
    OP_band, // boolean and of 2 bytes
    OP_sand, // boolean and of 2 short integers
    OP_ior, // boolean or of 2 integers
    OP_lor, // boolean or of 2 long integers
    OP_bor, // boolean or of 2 bytes
    OP_sor, // boolean or of 2 short integers
    OP_ixor, // boolean xor of 2 integers
    OP_lxor, // boolean xor of 2 long integers
    OP_bxor, // boolean xor of 2 bytes
    OP_sxor, // boolean xor of 2 short integers

    OP_i2l, // convert integer to long integer with sign extension
    OP_i2f, // convert integer to float
    OP_i2d, // convert integer to double
    OP_i2b, // convert integer to byte
    OP_i2s, // convert integer to short integer
    OP_i2a, // convert integer to address

    OP_iu2l, // convert unsigned integer to long integer with zero extension
    OP_iu2f, // convert unsigned integer to float
    OP_iu2d, // convert unsigned integer to double
    OP_iu2a, // convert unsigned integer to address

    OP_l2i, // convert long integer to integer
    OP_l2f, // convert long integer to float
    OP_l2d, // convert long integer to double
    OP_l2b, // convert long integer to byte
    OP_l2s, // convert long integer to short integer
    OP_l2a, // convert long integer to address

    OP_lu2f, // convert unsigned long integer to float
    OP_lu2d, // convert unsigned long integer to double
    OP_lu2a, // convert unsigned long integer to address

    OP_f2i, // convert float to integer
    OP_f2l, // convert float to long integer
    OP_f2d, // convert float to double
    OP_f2b, // convert float to byte
    OP_f2s, // convert float to short integer

    OP_d2i, // convert double to integer
    OP_d2l, // convert double to long integer
    OP_d2f, // convert double to float
    OP_d2b, // convert double to byte
    OP_d2s, // convert double to short integer

    OP_b2i, // convert byte to integer with sign extension
    OP_b2l, // convert byte to long integer with sign extension
    OP_b2f, // convert byte to float
    OP_b2d, // convert byte to double
    OP_b2s, // convert byte to short integer with sign extension
    OP_b2a, // convert byte to address

    OP_bu2i, // convert byte to integer with zero extension
    OP_bu2l, // convert byte to long integer with zero extension
    OP_bu2f, // convert unsigned byte to float
    OP_bu2d, // convert unsigned byte to double
    OP_bu2s, // convert byte to short integer with zero extension
    OP_bu2a, // convert unsigned byte to unsigned address

    OP_s2i, // convert short integer to integer with sign extension
    OP_s2l, // convert short integer to long integer with sign extension
    OP_s2f, // convert short integer to float
    OP_s2d, // convert short integer to double
    OP_s2b, // convert short integer to byte
    OP_s2a, // convert short integer to address

    OP_su2i, // zero extend short to int
    OP_su2l, // zero extend char to long
    OP_su2f, // convert char to float
    OP_su2d, // convert char to double
    OP_su2a, // convert char to address

    OP_a2i, // convert address to integer
    OP_a2l, // convert address to long integer
    OP_a2b, // convert address to byte
    OP_a2s, // convert address to short
    OP_icmpeq, // integer compare if equal
    OP_icmpne, // integer compare if not equal
    OP_icmplt, // integer compare if less than
    OP_icmpge, // integer compare if greater than or equal
    OP_icmpgt, // integer compare if greater than
    OP_icmple, // integer compare if less than or equal
    OP_iucmpeq, // unsigned integer compare if equal
    OP_iucmpne, // unsigned integer compare if not equal
    OP_iucmplt, // unsigned integer compare if less than
    OP_iucmpge, // unsigned integer compare if greater than or equal
    OP_iucmpgt, // unsigned integer compare if greater than
    OP_iucmple, // unsigned integer compare if less than or equal
    OP_lcmpeq, // long compare if equal
    OP_lcmpne, // long compare if not equal
    OP_lcmplt, // long compare if less than
    OP_lcmpge, // long compare if greater than or equal
    OP_lcmpgt, // long compare if greater than
    OP_lcmple, // long compare if less than or equal
    OP_lucmpeq, // unsigned long compare if equal
    OP_lucmpne, // unsigned long compare if not equal
    OP_lucmplt, // unsigned long compare if less than
    OP_lucmpge, // unsigned long compare if greater than or equal
    OP_lucmpgt, // unsigned long compare if greater than
    OP_lucmple, // unsigned long compare if less than or equal
    OP_fcmpeq, // float compare if equal
    OP_fcmpne, // float compare if not equal
    OP_fcmplt, // float compare if less than
    OP_fcmpge, // float compare if greater than or equal
    OP_fcmpgt, // float compare if greater than
    OP_fcmple, // float compare if less than or equal
    OP_fcmpequ, // float compare if equal or unordered
    OP_fcmpneu, // float compare if not equal or unordered
    OP_fcmpltu, // float compare if less than or unordered
    OP_fcmpgeu, // float compare if greater than or equal or unordered
    OP_fcmpgtu, // float compare if greater than or unordered
    OP_fcmpleu, // float compare if less than or equal or unordered
    OP_dcmpeq, // double compare if equal
    OP_dcmpne, // double compare if not equal
    OP_dcmplt, // double compare if less than
    OP_dcmpge, // double compare if greater than or equal
    OP_dcmpgt, // double compare if greater than
    OP_dcmple, // double compare if less than or equal
    OP_dcmpequ, // double compare if equal or unordered
    OP_dcmpneu, // double compare if not equal or unordered
    OP_dcmpltu, // double compare if less than or unordered
    OP_dcmpgeu, // double compare if greater than or equal or unordered
    OP_dcmpgtu, // double compare if greater than or unordered
    OP_dcmpleu, // double compare if less than or equal or unordered
    OP_acmpeq, // address compare if equal
    OP_acmpne, // address compare if not equal
    OP_acmplt, // address compare if less than
    OP_acmpge, // address compare if greater than or equal
    OP_acmpgt, // address compare if greater than
    OP_acmple, // address compare if less than or equal
    OP_bcmpeq, // byte compare if equal
    OP_bcmpne, // byte compare if not equal
    OP_bcmplt, // byte compare if less than
    OP_bcmpge, // byte compare if greater than or equal
    OP_bcmpgt, // byte compare if greater than
    OP_bcmple, // byte compare if less than or equal
    OP_bucmpeq, // unsigned byte compare if equal
    OP_bucmpne, // unsigned byte compare if not equal
    OP_bucmplt, // unsigned byte compare if less than
    OP_bucmpge, // unsigned byte compare if greater than or equal
    OP_bucmpgt, // unsigned byte compare if greater than
    OP_bucmple, // unsigned byte compare if less than or equal
    OP_scmpeq, // short integer compare if equal
    OP_scmpne, // short integer compare if not equal
    OP_scmplt, // short integer compare if less than
    OP_scmpge, // short integer compare if greater than or equal
    OP_scmpgt, // short integer compare if greater than
    OP_scmple, // short integer compare if less than or equal
    OP_sucmpeq, // char compare if equal
    OP_sucmpne, // char compare if not equal
    OP_sucmplt, // char compare if less than
    OP_sucmpge, // char compare if greater than or equal
    OP_sucmpgt, // char compare if greater than
    OP_sucmple, // char compare if less than or equal
    OP_lcmp, // long compare (1 if child1 > child2, 0 if child1 == child2, -1 if
             // child1 < child2)
    OP_fcmpl, // float compare l (1 if child1 > child2, 0 if child1 == child2, -1
              // if
              // child1 < child2 or unordered)
    OP_fcmpg, // float compare g (1 if child1 > child2 or unordered, 0 if child1
              // ==
              // child2, -1 if child1 < child2)
    OP_dcmpl, // double compare l (1 if child1 > child2, 0 if child1 == child2, -1
              // if
              // child1 < child2 or unordered)
    OP_dcmpg, // double compare g (1 if child1 > child2 or unordered, 0 if child1
              // ==
              // child2, -1 if child1 < child2)
    OP_ificmpeq, // integer compare and branch if equal
    OP_ificmpne, // integer compare and branch if not equal
    OP_ificmplt, // integer compare and branch if less than
    OP_ificmpge, // integer compare and branch if greater than or equal
    OP_ificmpgt, // integer compare and branch if greater than
    OP_ificmple, // integer compare and branch if less than or equal
    OP_ifiucmpeq, // unsigned integer compare and branch if equal
    OP_ifiucmpne, // unsigned integer compare and branch if not equal
    OP_ifiucmplt, // unsigned integer compare and branch if less than
    OP_ifiucmpge, // unsigned integer compare and branch if greater than or equal
    OP_ifiucmpgt, // unsigned integer compare and branch if greater than
    OP_ifiucmple, // unsigned integer compare and branch if less than or equal
    OP_iflcmpeq, // long compare and branch if equal
    OP_iflcmpne, // long compare and branch if not equal
    OP_iflcmplt, // long compare and branch if less than
    OP_iflcmpge, // long compare and branch if greater than or equal
    OP_iflcmpgt, // long compare and branch if greater than
    OP_iflcmple, // long compare and branch if less than or equal
    OP_iflucmpeq, // unsigned long compare and branch if equal
    OP_iflucmpne, // unsigned long compare and branch if not equal
    OP_iflucmplt, // unsigned long compare and branch if less than
    OP_iflucmpge, // unsigned long compare and branch if greater than or equal
    OP_iflucmpgt, // unsigned long compare and branch if greater than
    OP_iflucmple, // unsigned long compare and branch if less than or equal
    OP_iffcmpeq, // float compare and branch if equal
    OP_iffcmpne, // float compare and branch if not equal
    OP_iffcmplt, // float compare and branch if less than
    OP_iffcmpge, // float compare and branch if greater than or equal
    OP_iffcmpgt, // float compare and branch if greater than
    OP_iffcmple, // float compare and branch if less than or equal
    OP_iffcmpequ, // float compare and branch if equal or unordered
    OP_iffcmpneu, // float compare and branch if not equal or unordered
    OP_iffcmpltu, // float compare and branch if less than or unordered
    OP_iffcmpgeu, // float compare and branch if greater than or equal or
                  // unordered
    OP_iffcmpgtu, // float compare and branch if greater than or unordered
    OP_iffcmpleu, // float compare and branch if less than or equal or unordered
    OP_ifdcmpeq, // double compare and branch if equal
    OP_ifdcmpne, // double compare and branch if not equal
    OP_ifdcmplt, // double compare and branch if less than
    OP_ifdcmpge, // double compare and branch if greater than or equal
    OP_ifdcmpgt, // double compare and branch if greater than
    OP_ifdcmple, // double compare and branch if less than or equal
    OP_ifdcmpequ, // double compare and branch if equal or unordered
    OP_ifdcmpneu, // double compare and branch if not equal or unordered
    OP_ifdcmpltu, // double compare and branch if less than or unordered
    OP_ifdcmpgeu, // double compare and branch if greater than or equal or
                  // unordered
    OP_ifdcmpgtu, // double compare and branch if greater than or unordered
    OP_ifdcmpleu, // double compare and branch if less than or equal or unordered
    OP_ifacmpeq, // address compare and branch if equal
    OP_ifacmpne, // address compare and branch if not equal
    OP_ifacmplt, // address compare and branch if less than
    OP_ifacmpge, // address compare and branch if greater than or equal
    OP_ifacmpgt, // address compare and branch if greater than
    OP_ifacmple, // address compare and branch if less than or equal
    OP_ifbcmpeq, // byte compare and branch if equal
    OP_ifbcmpne, // byte compare and branch if not equal
    OP_ifbcmplt, // byte compare and branch if less than
    OP_ifbcmpge, // byte compare and branch if greater than or equal
    OP_ifbcmpgt, // byte compare and branch if greater than
    OP_ifbcmple, // byte compare and branch if less than or equal
    OP_ifbucmpeq, // unsigned byte compare and branch if equal
    OP_ifbucmpne, // unsigned byte compare and branch if not equal
    OP_ifbucmplt, // unsigned byte compare and branch if less than
    OP_ifbucmpge, // unsigned byte compare and branch if greater than or equal
    OP_ifbucmpgt, // unsigned byte compare and branch if greater than
    OP_ifbucmple, // unsigned byte compare and branch if less than or equal
    OP_ifscmpeq, // short integer compare and branch if equal
    OP_ifscmpne, // short integer compare and branch if not equal
    OP_ifscmplt, // short integer compare and branch if less than
    OP_ifscmpge, // short integer compare and branch if greater than or equal
    OP_ifscmpgt, // short integer compare and branch if greater than
    OP_ifscmple, // short integer compare and branch if less than or equal
    OP_ifsucmpeq, // char compare and branch if equal
    OP_ifsucmpne, // char compare and branch if not equal
    OP_ifsucmplt, // char compare and branch if less than
    OP_ifsucmpge, // char compare and branch if greater than or equal
    OP_ifsucmpgt, // char compare and branch if greater than
    OP_ifsucmple, // char compare and branch if less than or equal
    OP_loadaddr, // load address of non-heap storage item (Auto, Parm, Static or
                 // Method)
    OP_ZEROCHK, // Zero-check an int.  Symref indicates call to perform when first
                // child is zero.  Other children are arguments to the call.
    OP_callIf, // Call symref if first child evaluates to true.  Other childrem
               // are
               // arguments to the call.
    OP_iRegLoad, // Load integer global register
    OP_aRegLoad, // Load address global register
    OP_lRegLoad, // Load long integer global register
    OP_fRegLoad, // Load float global register
    OP_dRegLoad, // Load double global register
    OP_sRegLoad, // Load short global register
    OP_bRegLoad, // Load byte global register
    OP_iRegStore, // Store integer global register
    OP_aRegStore, // Store address global register
    OP_lRegStore, // Store long integer global register
    OP_fRegStore, // Store float global register
    OP_dRegStore, // Store double global register
    OP_sRegStore, // Store short global register
    OP_bRegStore, // Store byte global register
    OP_GlRegDeps, // Global Register Dependency List
    OP_iternary, // Ternary Operator:  Based on the result of the first child,
                 // take
                 // the value of the
    OP_lternary, //   second (first child evaluates to true) or third(first child
                 //   evaluates to false) child
    OP_bternary, //
    OP_sternary, //
    OP_aternary, //
    OP_fternary, //
    OP_dternary, //
    OP_treetop, // tree top to anchor subtrees with side-effects
    OP_MethodEnterHook, // called after a frame is built, temps initialized, and
                        // monitor acquired (if necessary)
    OP_MethodExitHook, // called immediately before returning, frame not yet
                       // collapsed, monitor released (if necessary)
    OP_PassThrough, // Dummy node that represents its single child.
    OP_compressedRefs, // no-op anchor providing optimizable subexpressions used
                       // for compression/decompression.  First child is address
                       // load/store, second child is heap base displacement
    OP_BBStart, // Start of Basic Block
    OP_BBEnd, // End of Basic Block

    OP_virem, // vector integer remainder
    OP_vimin, // vector integer minimum
    OP_vimax, // vector integer maximum
    OP_vigetelem, // get vector int element
    OP_visetelem, // set vector int element
    OP_vimergel, // vector int merge low
    OP_vimergeh, // vector int merge high

    OP_vicmpeq, // vector integer compare equal  (return vector mask)
    OP_vicmpgt, // vector integer compare greater than
    OP_vicmpge, // vector integer compare greater equal
    OP_vicmplt, // vector integer compare less than
    OP_vicmple, // vector integer compare less equal

    OP_vicmpalleq, // vector integer all equal (return boolean)
    OP_vicmpallne, // vector integer all not equal
    OP_vicmpallgt, // vector integer all greater than
    OP_vicmpallge, // vector integer all greater equal
    OP_vicmpalllt, // vector integer all less than
    OP_vicmpallle, // vector integer all less equal
    OP_vicmpanyeq, // vector integer any equal
    OP_vicmpanyne, // vector integer any not equal
    OP_vicmpanygt, // vector integer any greater than
    OP_vicmpanyge, // vector integer any greater equal
    OP_vicmpanylt, // vector integer any less than
    OP_vicmpanyle, // vector integer any less equal

    OP_vnot, // vector boolean not
    OP_vselect, // vector select
    OP_vperm, // vector permute

    OP_vsplats, // vector splats
    OP_vdmergel, // vector double merge low
    OP_vdmergeh, // vector double merge high
    OP_vdsetelem, // set vector double element
    OP_vdgetelem, // get vector double element
    OP_vdsel, // get vector select double

    OP_vdrem, // vector double remainder
    OP_vdmadd, // vector double fused multiply add
    OP_vdnmsub, // vector double fused negative multiply subtract
    OP_vdmsub, // vector double fused multiply subtract
    OP_vdmax, // vector double maximum
    OP_vdmin, // vector double minimum

    OP_vdcmpeq, // vector double compare equal  (return vector mask)
    OP_vdcmpne, // vector double compare not equal  (return vector mask)
    OP_vdcmpgt, // vector double compare greater than
    OP_vdcmpge, // vector double compare greater equal
    OP_vdcmplt, // vector double compare less than
    OP_vdcmple, // vector double compare less equal

    OP_vdcmpalleq, // vector double compare all equal  (return boolean)
    OP_vdcmpallne, // vector double compare all not equal  (return boolean)
    OP_vdcmpallgt, // vector double compare all greater than
    OP_vdcmpallge, // vector double compare all greater equal
    OP_vdcmpalllt, // vector double compare all less than
    OP_vdcmpallle, // vector double compare all less equal

    OP_vdcmpanyeq, // vector double compare any equal  (return boolean)
    OP_vdcmpanyne, // vector double compare any not equal  (return boolean)
    OP_vdcmpanygt, // vector double compare any greater than
    OP_vdcmpanyge, // vector double compare any greater equal
    OP_vdcmpanylt, // vector double compare any less than
    OP_vdcmpanyle, // vector double compare any less equal
    OP_vdsqrt, // vector double square root
    OP_vdlog, // vector double natural log

    /* Begin general vector opcodes */
    OP_vinc, // vector increment
    OP_vdec, // vector decrement
    OP_vneg, // vector negation
    OP_vcom, // vector complement
    OP_vadd, // vector add
    OP_vsub, // vector subtract
    OP_vmul, // vector multiply
    OP_vdiv, // vector divide
    OP_vrem, // vector remainder
    OP_vand, // vector logical AND
    OP_vor, // vector logical OR
    OP_vxor, // vector exclusive OR integer
    OP_vshl, // vector shift left
    OP_vushr, // vector shift right logical
    OP_vshr, // vector shift right arithmetic
    OP_vcmpeq, // vector compare equal
    OP_vcmpne, // vector compare not equal
    OP_vcmplt, // vector compare less than
    OP_vucmplt, // vector unsigned compare less than
    OP_vcmpgt, // vector compare greater than
    OP_vucmpgt, // vector unsigned compare greater than
    OP_vcmple, // vector compare less or equal
    OP_vucmple, // vector unsigned compare less or equal
    OP_vcmpge, // vector compare greater or equal
    OP_vucmpge, // vector unsigned compare greater or equal
    OP_vload, // load vector
    OP_vloadi, // load indirect vector
    OP_vstore, // store vector
    OP_vstorei, // store indirect vector
    OP_vrand, // AND all elements into single value of element size
    OP_vreturn, // return a vector
    OP_vcall, // direct call returning a vector
    OP_vcalli, // indirect call returning a vector
    OP_vternary, // vector ternary operator
    OP_v2v, // vector to vector conversion. preserves bit pattern (noop), only
            // changes datatype
    OP_vl2vd, // vector to vector conversion. converts each long element to double
    OP_vconst, // vector constant
    OP_getvelem, // get vector element, returns a scalar
    OP_vsetelem, // vector set element

    OP_vbRegLoad, // Load vector global register
    OP_vsRegLoad, // Load vector global register
    OP_viRegLoad, // Load vector global register
    OP_vlRegLoad, // Load vector global register
    OP_vfRegLoad, // Load vector global register
    OP_vdRegLoad, // Load vector global register
    OP_vbRegStore, // Store vector global register
    OP_vsRegStore, // Store vector global register
    OP_viRegStore, // Store vector global register
    OP_vlRegStore, // Store vector global register
    OP_vfRegStore, // Store vector global register
    OP_vdRegStore, // Store vector global register

    OP_iuconst, // load unsigned integer constant (32-but unsigned)
    OP_luconst, // load unsigned long integer constant (64-bit unsigned)
    OP_buconst, // load unsigned byte integer constant (8-bit unsigned)
    OP_iuload, // load unsigned integer
    OP_luload, // load unsigned long integer
    OP_buload, // load unsigned byte
    OP_iuloadi, // load indirect unsigned integer
    OP_luloadi, // load indirect unsigned long integer
    OP_buloadi, // load indirect unsigned byte
    OP_iustore, // store unsigned integer
    OP_lustore, // store unsigned long integer
    OP_bustore, // store unsigned byte
    OP_iustorei, // store indirect unsigned integer       (child1 a, child2 i)
    OP_lustorei, // store indirect unsigned long integer  (child1 a, child2 l)
    OP_bustorei, // store indirect unsigned byte          (child1 a, child2 b)
    OP_iureturn, // return an unsigned integer
    OP_lureturn, // return a long unsigned integer
    OP_iucall, // direct call returning unsigned integer
    OP_lucall, // direct call returning unsigned long integer
    OP_iuadd, // add 2 unsigned integers
    OP_luadd, // add 2 unsigned long integers
    OP_buadd, // add 2 unsigned bytes
    OP_iusub, // subtract 2 unsigned integers       (child1 - child2)
    OP_lusub, // subtract 2 unsigned long integers  (child1 - child2)
    OP_busub, // subtract 2 unsigned bytes          (child1 - child2)
    OP_iuneg, // negate an unsigned integer
    OP_luneg, // negate a unsigned long integer
    OP_iushl, // shift unsigned integer left       (child1 << child2)
    OP_lushl, // shift unsigned long integer left  (child1 << child2)
    OP_f2iu, // convert float to unsigned integer
    OP_f2lu, // convert float to unsigned long integer
    OP_f2bu, // convert float to unsigned byte
    OP_f2c, // convert float to char
    OP_d2iu, // convert double to unsigned integer
    OP_d2lu, // convert double to unsigned long integer
    OP_d2bu, // convert double to unsigned byte
    OP_d2c, // convert double to char
    OP_iuRegLoad, // Load unsigned integer global register
    OP_luRegLoad, // Load unsigned long integer global register
    OP_iuRegStore, // Store unsigned integer global register
    OP_luRegStore, // Store long integer global register
    OP_iuternary, // second or the third child.  Analogous to the "condition ? a :
                  // b"
                  // operations in C/Java.
    OP_luternary, //
    OP_buternary, //
    OP_suternary, //
    OP_cconst, // load unicode constant (16-bit unsigned)
    OP_cload, // load short unsigned integer
    OP_cloadi, // load indirect unsigned short integer
    OP_cstore, // store unsigned short integer
    OP_cstorei, // store indirect unsigned short integer (child1 a, child2 c)
    OP_monent, // acquire lock for synchronising method
    OP_monexit, // release lock for synchronising method
    OP_monexitfence, // denotes the end of a monitored region solely for live
                     // monitor
                     // meta data
    OP_tstart, // transaction begin
    OP_tfinish, // transaction end
    OP_tabort, // transaction abort
    OP_instanceof, // instanceof - symref is the class object, cp index is in the
                   // "int" field, child is the object reference
    OP_checkcast, // checkcast
    OP_checkcastAndNULLCHK, // checkcast and NULL check the underlying object
                            // reference
    OP_New, // new - child is class
    OP_newarray, // new array of primitives
    OP_anewarray, // new array of objects
    OP_variableNew, // new - child is class, type not known at compile time
    OP_variableNewArray, // new array - type not known at compile time, type must
                         // be
                         // a j9class, do not use type enums
    OP_multianewarray, // multi-dimensional new array of objects
    OP_arraylength, // number of elements in an array
    OP_contigarraylength, // number of elements in a contiguous array
    OP_discontigarraylength, // number of elements in a discontiguous array
    OP_icalli, // indirect call returning integer (child1 is addr of function)
    OP_iucalli, // indirect call returning unsigned integer (child1 is addr of
                // function)
    OP_lcalli, // indirect call returning long integer (child1 is addr of
               // function)
    OP_lucalli, // indirect call returning unsigned long integer (child1 is addr
                // of
                // function)
    OP_fcalli, // indirect call returning float (child1 is addr of function)
    OP_dcalli, // indirect call returning double (child1 is addr of function)
    OP_acalli, // indirect call returning reference
    OP_calli, // indirect call returning void (child1 is addr of function)
    OP_fence, // barrier to optimization
    OP_luaddh, // add 2 unsigned long integers (the high parts of prior luadd) as
               // high part of 128bit addition.
    OP_cadd, // add 2 unsigned short integers
    OP_aiadd, // add integer to address with address result (child1 a, child2 i)
    OP_aiuadd, // add unsigned integer to address with address result (child1 a,
               // child2 i)
    OP_aladd, // add long integer to address with address result (child1 a, child2
              // i)
              // (64-bit only)
    OP_aluadd, // add unsigned long integer to address with address result (child1
               // a,
               // child2 i) (64-bit only)
    OP_lusubh, // subtract 2 unsigned long integers (the high parts of prior
               // lusub)
               // as high part of 128bit subtraction.
    OP_csub, // subtract 2 unsigned short integers (child1 - child2)
    OP_imulh, // multiply 2 integers, and return the high word of the product
    OP_iumulh, // multiply 2 unsigned integers, and return the high word of the
               // product
    OP_lmulh, // multiply 2 long integers, and return the high word of the product
    OP_lumulh, // multiply 2 unsigned long integers, and return the high word of
               // the
               // product
    OP_ibits2f, // type-coerce int to float
    OP_fbits2i, // type-coerce float to int
    OP_lbits2d, // type-coerce long to double
    OP_dbits2l, // type-coerce double to long
    OP_lookup, // lookupswitch (child1 is selector expression, child2 the default
               // destination, subsequent children are case nodes
    OP_trtLookup, // special lookupswitch (child1 must be trt, child2 the default
                  // destination, subsequent children are case nodes) The internal
                  // control flow is similar to lookup, but each CASE represents a
                  // special semantics associated with a flag on it
    OP_Case, // case nodes that are children of TR_switch.  Uses the
             // branchdestination and the int const field
    OP_table, // tableswitch (child1 is the selector, child2 the default
              // destination,
    // subsequent children are the branch targets (the last child may be a
    // branch table address, use getCaseIndexUpperBound() when iterating
    // over branch targets)
    OP_exceptionRangeFence, // (J9) SymbolReference is the aliasing effect,
                            // initialiser is where the code address gets put when
    // binary is generated used for delimiting function, try
    // blocks, catch clauses, finally clauses, etc.
    OP_dbgFence, // used to delimit code (stmts) for debug info.  Has no symbol
                 // reference.
    OP_NULLCHK, // Null check a pointer.  child 1 is indirect reference. Symbolref
                // indicates failure action/destination
    OP_ResolveCHK, // Resolve check a static, field or method. child 1 is
                   // reference
    // to be resolved. Symbolref indicates failure action/destination
    OP_ResolveAndNULLCHK, // Resolve check a static, field or method and Null
                          // check
                          // the underlying pointer.  child 1 is reference to be
    // resolved. Symbolref indicates failure action/destination
    OP_DIVCHK, // Divide by zero check. child 1 is the divide. Symbolref indicates
               // failure action/destination
    OP_OverflowCHK, // Overflow check. child 1 is the operation node(add, mul,
                    // sub).
    // Child 2 and child 3 are the operands of the operation of the
    // operation. Symbolref indicates failure action/destination
    OP_UnsignedOverflowCHK, // UnsignedOverflow check. child 1 is the operation
                            // node(add, mul, sub). Child 2 and child 3 are the
    // operands of the operation of the operation. Symbolref
    // indicates failure action/destination
    OP_BNDCHK, // Array bounds check, checks that child 1 > child 2 >= 0 (child 1
               // is
    // bound, 2 is index). Symbolref indicates failure action/destination
    OP_ArrayCopyBNDCHK, // Array copy bounds check, checks that child 1 >=
                        // child 2.
                        // Symbolref indicates failure action/destination
    OP_BNDCHKwithSpineCHK, // Array bounds check and spine check
    OP_SpineCHK, // Check if the base array has a spine
    OP_ArrayStoreCHK, // Array store check. child 1 is object, 2 is array.
                      // Symbolref
                      // indicates failure action/destination
    OP_ArrayCHK, // Array compatibility check. child 1 is object1, 2 is object2.
                 // Symbolref indicates failure action/destination
    OP_Ret, // Used by ilGen only
    OP_arraycopy, // Call to System.arraycopy that may be partially inlined
    OP_arrayset, // Inline code for memory initialization of part of an array
    OP_arraytranslate, // Inline code for translation of part of an array to
                       // another
                       // form via lookup
    OP_arraytranslateAndTest, // Inline code for scanning of part of an array for
                              // a
                              // particular 8-bit character
    OP_long2String, // Convert integer/long value to String
    OP_bitOpMem, // bit operations (AND, OR, XOR) for memory to memory
    OP_bitOpMemND, // 3 operand(source1,source2,target) version of bitOpMem
    OP_arraycmp, // Inline code for memory comparison of part of an array
    OP_arraycmpWithPad, // memory comparison when src1 length != src2 length and
                        // padding is needed
    OP_allocationFence, // Internal fence guarding escape of newObject & final
                        // fields
                        // - eliminatable
    OP_loadFence, // JEP171: prohibits loadLoad and loadStore reordering (on
                  // globals)
    OP_storeFence, // JEP171: prohibits loadStore and storeStore reordering (on
                   // globals)
    OP_fullFence, // JEP171: prohibits loadLoad, loadStore, storeLoad, and
                  // storeStore
                  // reordering (on globals)
    OP_MergeNew, // Parent for New etc. nodes that can all be allocated together
    OP_computeCC, // compute Condition Codes
    OP_butest, // zEmulator: mask unsigned byte (UInt8) and set condition codes
    OP_sutest, // zEmulator: mask unsigned short (UInt16) and set condition codes

    OP_bucmp, // Currently only valid for zEmulator. Based on the ordering of the
              // two
    // children set the return value:
    OP_bcmp, //    0 : child1 == child2
    OP_sucmp, //    1 : child1 < child2
    OP_scmp, //    2 : child1 > child2
    OP_iucmp, //
    OP_icmp, //
    OP_lucmp, //

    OP_ificmpo, // integer compare and branch if overflow
    OP_ificmpno, // integer compare and branch if not overflow
    OP_iflcmpo, // long compare and branch if overflow
    OP_iflcmpno, // long compare and branch if not overflow
    OP_ificmno, // integer compare negative and branch if overflow
    OP_ificmnno, // integer compare negative and branch if not overflow
    OP_iflcmno, // long compare negative and branch if overflow
    OP_iflcmnno, // long compare negative and branch if not overflow

    OP_iuaddc, // Currently only valid for zEmulator.  Add two unsigned ints with
               // carry
    OP_luaddc, // Add two longs with carry
    OP_iusubb, // Subtract two ints with borrow
    OP_lusubb, // Subtract two longs with borrow

    OP_icmpset, // icmpset(pointer,c,r): compare *pointer with c, if it matches,
                // replace with r.  Returns 0 on match, 1 otherwise
    OP_lcmpset, // the operation is done atomically - return type is int for both
                // [il]cmpset
    OP_bztestnset, // bztestnset(pointer,c): atomically sets *pointer to c and
    // returns the original value of *p (represents Test And Set on Z)

    // the atomic ops.. atomically update the symref.  first child is address,
    // second child is the RHS interestingly, these ops act like loads and stores
    // at the same time
    OP_ibatomicor, //
    OP_isatomicor, //
    OP_iiatomicor, //
    OP_ilatomicor, //

    OP_dexp, // double exponent

    OP_branch, // generic branch --> DEPRECATED use TR::case instead
    OP_igoto, // indirect goto, branches to the address specified by a child

    OP_bexp, // signed byte exponent  (raise signed byte to power)
    OP_buexp, // unsigned byte exponent
    OP_sexp, // short exponent
    OP_cexp, // unsigned short exponent
    OP_iexp, // integer exponent
    OP_iuexp, // unsigned integer exponent
    OP_lexp, // long exponent
    OP_luexp, // unsigned long exponent
    OP_fexp, // float exponent
    OP_fuexp, // float base to unsigned integral exponent
    OP_duexp, // double base to unsigned integral exponent

    OP_ixfrs, // transfer sign integer
    OP_lxfrs, // transfer sign long
    OP_fxfrs, // transfer sign float
    OP_dxfrs, // transfer sign double

    OP_fint, // truncate float to int
    OP_dint, // truncate double to int
    OP_fnint, // round float to nearest int
    OP_dnint, // round double to nearest int

    OP_fsqrt, // square root of float
    OP_dsqrt, // square root of double

    OP_getstack, // returns current value of SP
    OP_dealloca, // resets value of SP

    OP_ishfl, // int shift logical
    OP_lshfl, // long shift logical
    OP_iushfl, // unsigned int shift logical
    OP_lushfl, // unsigned long shift logical
    OP_bshfl, // byte shift logical
    OP_sshfl, // short shift logical
    OP_bushfl, // unsigned byte shift logical
    OP_sushfl, // unsigned short shift logical

    OP_idoz, // difference or zero

    OP_dcos, // cos of double, returning double
    OP_dsin, // sin of double, returning double
    OP_dtan, // tan of double, returning double

    OP_dcosh, // cos of double, returning double
    OP_dsinh, // sin of double, returning double
    OP_dtanh, // tan of double, returning double

    OP_dacos, // arccos of double, returning double
    OP_dasin, // arcsin of double, returning double
    OP_datan, // arctan of double, returning double

    OP_datan2, // arctan2 of double, returning double

    OP_dlog, // log of double, returning double

    OP_imulover, // (int) overflow predicate of int multiplication

    OP_dfloor, // floor of double, returning double
    OP_ffloor, // floor of float, returning float
    OP_dceil, // ceil of double, returning double
    OP_fceil, // ceil of float, returning float
    OP_ibranch, // generic indirct branch --> first child is a constant indicating
                // the mask
    OP_mbranch, // generic branch to multiple potential targets
    OP_getpm, // get program mask
    OP_setpm, // set program mask
    OP_loadAutoOffset, // loads the offset (from the SP) of an auto

    OP_imax, // max of 2 or more integers
    OP_iumax, // max of 2 or more unsigned integers
    OP_lmax, // max of 2 or more longs
    OP_lumax, // max of 2 or more unsigned longs
    OP_fmax, // max of 2 or more floats
    OP_dmax, // max of 2 or more doubles

    OP_imin, // min of 2 or more integers
    OP_iumin, // min of 2 or more unsigned integers
    OP_lmin, // min of 2 or more longs
    OP_lumin, // min of 2 or more unsigned longs
    OP_fmin, // min of 2 or more floats
    OP_dmin, // min of 2 or more doubles

    OP_trt, // translate and test
    OP_trtSimple, // same as TRT but ignoring the returned source byte address and
                  // table entry value

    OP_ihbit,
    OP_ilbit,
    OP_inolz,
    OP_inotz,
    OP_ipopcnt,

    OP_lhbit,
    OP_llbit,
    OP_lnolz,
    OP_lnotz,
    OP_lpopcnt,

    OP_ibyteswap, // swap bytes in an integer

    OP_bbitpermute,
    OP_sbitpermute,
    OP_ibitpermute,
    OP_lbitpermute,

    OP_Prefetch, // Prefetch

};
typedef enum JIT_NodeOpCode JIT_NodeOpCode;

/**
 * Create a Node with no children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode(JIT_NodeOpCode opcode);

/**
 * Create a Node with one child. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode1C(JIT_NodeOpCode opcode, JIT_NodeRef c1);

/**
 * Create a Node with two children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode2C(JIT_NodeOpCode opcode, JIT_NodeRef c1, JIT_NodeRef c2);

/**
 * Create a Node with three children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode3C(JIT_NodeOpCode opcode, JIT_NodeRef c1, JIT_NodeRef c2, JIT_NodeRef c3);

/**
 * If the given node is not a TreeTrop - creates a new TreeTop node
 * and anchors the node in the treetop.
 */
extern JIT_TreeTopRef JIT_GenerateTreeTop(JIT_ILInjectorRef ilinjector, JIT_NodeRef n);

/* Convert a BlockRef to CFGNodeRef */
extern JIT_CFGNodeRef JIT_BlockAsCFGNode(JIT_BlockRef b);

/**
 * Adds an edge in the control flow graph - note that blocks are CFGNodes so
 * you can convert blocks to CFGNodes by calling JIT_NodeAsCFGNode().
 */
extern void JIT_CFGAddEdge(JIT_ILInjectorRef ilinjector, JIT_CFGNodeRef from, JIT_CFGNodeRef to);

/**
 * Returns the node that is the bottom of the CFG
 */
extern JIT_CFGNodeRef JIT_GetCFGEnd(JIT_ILInjectorRef ilinjector);

/**
 * Creates a temporary value on the stack of required type; returns a
 * SymbolRef that can be used to load/store.
 */
extern JIT_SymbolRef JIT_CreateTemporary(JIT_ILInjectorRef ilinjector, JIT_Type type);

/**
 * Creates a temporary array value on the stack; the value will be of
 * type JIT_Aggregate. To load or store values, first obtain the symbol's
 * address using JIT_LoadAddress
 */
extern JIT_SymbolRef JIT_CreateLocalByteArray(JIT_ILInjectorRef ilinjector, uint32_t size);

/**
 * Gets the type of the SymbolRef.
 */
extern JIT_Type JIT_GetSymbolType(JIT_SymbolRef sym);

/**
 * Load value at a temporary
 */
extern JIT_NodeRef JIT_LoadTemporary(JIT_ILInjectorRef ilinjector, JIT_SymbolRef symbol);

/**
 * Store value to a temporary; the store is created as a TreeTop
 */
extern void JIT_StoreToTemporary(JIT_ILInjectorRef ilinjector, JIT_SymbolRef symbol, JIT_NodeRef value);

/**
 * Loads the address of a local temporary or array
 */
extern JIT_NodeRef JIT_LoadAddress(JIT_ILInjectorRef ilinjector, JIT_SymbolRef symbol);

/**
 * Load a value from specific offset within array; note offset must be exact
 * byte offset (presumably suitably aligned)
 */
extern JIT_NodeRef JIT_ArrayLoad(
    JIT_ILInjectorRef ilinjector, JIT_NodeRef address, JIT_NodeRef byte_offset, JIT_Type value_type);
extern JIT_NodeRef JIT_ArrayLoadAt(
    JIT_ILInjectorRef ilinjector, uint64_t symbolId, JIT_NodeRef basenode, int64_t idx, JIT_Type dt);

/**
 * Store a value at specific array offset; note offset must be exact byte
 * offset (presumably suitably aligned)
 */
extern void JIT_ArrayStore(
    JIT_ILInjectorRef ilinjector, JIT_NodeRef address, JIT_NodeRef byte_offset, JIT_NodeRef valuenode);
extern void JIT_ArrayStoreAt(
    JIT_ILInjectorRef ilinjector, uint64_t symbolId, JIT_NodeRef basenode, int64_t idx, JIT_NodeRef valuenode);

/**
 * Load the specified parameter, slots start at 0.
 */
extern JIT_NodeRef JIT_LoadParameter(JIT_ILInjectorRef ilinjector, int32_t slot);

/**
 * Convert a value to target type; note that if conversion is not valid then
 * the call will return NULL.
 */
extern JIT_NodeRef JIT_ConvertTo(
    JIT_ILInjectorRef ilinjector, JIT_NodeRef value, JIT_Type targetType, bool needUnsigned);

/**
 * Obtain a symbol for a known function
 */
JIT_SymbolRef JIT_GetFunctionSymbol(JIT_ILInjectorRef ilinjector, const char* name);

/**
 * Call a function; function must be registered already
 */
extern JIT_NodeRef JIT_Call(JIT_ILInjectorRef ilinjector, const char* functionName, int32_t numArgs, JIT_NodeRef* args);

/**
 * Call a function via a runtime function ptr
 */
extern JIT_NodeRef JIT_IndirectCall(
    JIT_ILInjectorRef ilinjector, JIT_NodeRef funcptr, JIT_Type return_type, int32_t numArgs, JIT_NodeRef* args);

/**
 * Generate unconditional jump to given block; CFG will be updated to add an
 * edge from current block to target block; the jump instruction will be
 * anchored in a TreeTop. The current block will remain as is - caller must
 * update current block.
 */
extern JIT_NodeRef JIT_Goto(JIT_ILInjectorRef ilinjector, JIT_BlockRef block);

/**
 * Generate return instruction; CFG will be updated to add an edge from
 * current block to end of CFG; the return instruction will be anchored in a
 * TreeTop. The current block will remain as is - caller must update current
 * block.
 */
extern JIT_NodeRef JIT_ReturnValue(JIT_ILInjectorRef ilinjector, JIT_NodeRef value);
extern JIT_NodeRef JIT_ReturnNoValue(JIT_ILInjectorRef ilinjector);

/**
 * If given value != 0 then jump to blockOnNonZero.
 * CFG will be updated to add edge from current block to blockOnNonZero.
 * The current block will not be updated; note that caller must handle
 * false condition.
 *
 * Note that OMR expects a new block to start after this IL. Control
 * falls through to the new block. If you need to provide an alternate
 * destination then you can put a Goto instruction in the new block.
 *
 * You must also manually add a CFG edge from current block to the
 * next block.
 *
 * Suppose current block is b1, and next block is b2.
 * Also suppose that the IfNotZero target block is b10.
 * Aand alternate destination is b13.
 * Then you must do:
 *
 * JIT_IfNotZeroValue(injector, cond, b10);
 * // Create block b2
 * JIT_CFGAddEdge(injector, JIT_BlockAsCFGNode(b1), JIT_BlockAsCFGNode(b2));
 * JIT_SetCurrentBlock(b2);
 * JIT_Goto(injector, b13); // Must be in the new block
 */
extern JIT_NodeRef JIT_IfNotZeroValue(JIT_ILInjectorRef ilinjector, JIT_NodeRef value, JIT_BlockRef blockOnNonZero);

/**
 * If given value == 0 then jump to blockOnZero.
 * CFG will be updated to add edge from current block to blockOnZero.
 * The current block will not be updated; note that caller must handle
 * false condition.
 *
 * The same considerations apply as for JIT_IfNotZeroValue() above.
 */
extern JIT_NodeRef JIT_IfZeroValue(JIT_ILInjectorRef ilinjector, JIT_NodeRef value, JIT_BlockRef blockOnZero);

/**
 * C style switch; CFG will be updated to add edge from current block
 * to each of the case blocks, and the default block.
 */
extern JIT_NodeRef JIT_Switch(JIT_ILInjectorRef ilinjector, JIT_NodeRef expr, JIT_BlockRef default_branch,
    int num_cases, JIT_BlockRef* case_branches, int32_t* case_values);

/**
 * Checks if the symbol is a temporary
 */
extern bool JIT_IsTemporary(JIT_ILInjectorRef ilinjector, JIT_SymbolRef sym);

/**
 * Gets the Opcode for this node
 */
extern JIT_NodeOpCode JIT_GetOpCode(JIT_NodeRef noderef);

/**
 * If the opcode for the node has a symbol reference then
 * gets the symbol reference for the node else returns NULL.
 */
extern JIT_SymbolRef JIT_GetSymbolForNode(JIT_NodeRef noderef);

/**
 * Optimizer hints
 */
extern void JIT_SetMayHaveLoops(JIT_ILInjectorRef ilinjector);
extern void JIT_SetMayHaveNestedLoops(JIT_ILInjectorRef ilinjector);

/**
 * Inform the compiler that the automatic variable had its
 * address taken, hence the variable should be considered as aliased
 * when calling functions etc.
 */
extern void JIT_SetAutoAddressTaken(JIT_ILInjectorRef ilinjector, JIT_SymbolRef symbol);

#ifdef __cplusplus
}
#endif

#endif
