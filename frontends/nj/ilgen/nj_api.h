/*******************************************************************************
 * Copyright (c) 2000, 2018 IBM Corp. and others
 *
 * This program and the accompanying materials are made available under
 * the terms of the Eclipse Public License 2.0 which accompanies this
 * distribution and is available at http://eclipse.org/legal/epl-2.0
 * or the Apache License, Version 2.0 which accompanies this distribution
 * and is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * This Source Code may also be made available under the following Secondary
 * Licenses when the conditions for such availability set forth in the
 * Eclipse Public License, v. 2.0 are satisfied: GNU General Public License,
 * version 2 with the GNU Classpath Exception [1] and GNU General Public
 * License, version 2 with the OpenJDK Assembly Exception [2].
 *
 * [1] https://www.gnu.org/software/classpath/license.html
 * [2] http://openjdk.java.net/legal/assembly-exception.html
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH
 *Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
 *******************************************************************************/
#ifndef JIT_api_h
#define JIT_api_h

#include <stdint.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**
 * The Jit Context defines a container for the Jit machinery and
 * also acts as the repository of the compiled functions. The Jit
 * Context must be kept alive as long as any functions within it are
 * needed. Deleting the Jit Context may delete all compiled
 * functions managed by the context (this happens if there are
 * no more alive JIT contexts).
 *
 * Note that at present OMR JIT maintains a global
 * Code Cache behind the scenes. Hence compiled code may live on
 * longer than expected although once the JIT Context is dead
 * you may not be able to access the compiled code held in
 * the code cache.
 *
 * In future my hope is to make the global Code Cache local
 * to the JIT Context.
 */
typedef struct JIT_Context *JIT_ContextRef;

/**
 * Creates a Jit Context.
 * Will Initialize the OMR JIT engine if not already initalized
 */
extern JIT_ContextRef JIT_CreateContext();

/**
 * Destroys the Jit Context. Note that all compiled functions
 * managed by this context may die at this point.
 * JIT Contexts are counted such that if this is the last
 * live context then the OMR JIT will be shutdown at this
 * point.
 */
extern void JIT_DestroyContext(JIT_ContextRef);

/*
 * OMR Types
 */
enum JIT_Type {
  JIT_NoType = 0,
  JIT_Int8,
  JIT_Int16,
  JIT_Int32,
  JIT_Int64,
  JIT_Float,
  JIT_Double,
  JIT_Address, /* pointer */
  JIT_VectorInt8,
  JIT_VectorInt16,
  JIT_VectorInt32,
  JIT_VectorInt64,
  JIT_VectorFloat,
  JIT_VectorDouble,
  JIT_Aggregate, /* A byte array is of this type for example */
};
typedef enum JIT_Type JIT_Type;

/**
 * The JIT ILBuilder callback must be implemented by the
 * user. All of the IL generation is meant to happen here.
 * Note that during compilation certain thread local variables are
 * used; including a Compiler object which is stored in the
 * thread local context.
 *
 * Userdata is whatever was given to JIT_CreateFunctionBuilder.
 */
typedef struct JIT_ILInjector *JIT_ILInjectorRef;
typedef bool (*JIT_ILBuilder)(JIT_ILInjectorRef, void *userdata);

/**
 * A Function Builder is used to generate code for a single
 * C function equivalent. Once the code is generated by invoking
 * JIT_Compile() on the builder, the builder itself can be destroyed as the
 * compiled function lives on in the associated Jit Context.
 */
typedef struct JIT_FunctionBuilder *JIT_FunctionBuilderRef;

/**
 * Creates a new function builder object. The builder is used to construct the
 * code that will go into one function. Note that this function only
 * creates the function type - the actual IL generation happens
 * when JIT_Compile() is called. After the function is
 * compiled the builder object can be thrown away - the compiled function
 * will live as long as the owning Jit Context lives.
 */
extern JIT_FunctionBuilderRef
JIT_CreateFunctionBuilder(JIT_ContextRef context, const char *name,
                          JIT_Type return_type, int param_count,
                          const JIT_Type *parameters, JIT_ILBuilder ilbuilder,
                          void *userdata);

/**
 * Register an external function (not managed by JIT). Note that
 * any exsiting function regsitered by the same name will be
 * over-written.
 */
extern void JIT_RegisterFunction(JIT_ContextRef context, const char *name,
                                 enum JIT_Type return_type, int param_count,
                                 const JIT_Type *parameters, void *functionptr);

/**
 * Get a registered function by name. This will return
 * NULL if no function exists by that name.
 */
void *JIT_GetFunction(JIT_ContextRef ctx, const char *name);

/**
 * Destroys the function builder object. Note that this will not delete the
 * compiled function created using this builder - as the compiled function lives
 * in the owning Jit Context.
 */
extern void JIT_DestroyFunctionBuilder(JIT_FunctionBuilderRef);

/*
IMPORTANT Notes:

The IL is a DAG rather than linear IR.

The IL is arranged in basic blocks of type JIT_BlockRef (Block). The
instructions are represented by JIT_NodeRef (Node) objects which are DAG nodes.
The Nodes are anchored in JIT_TreeTopRefs (TreeTops). The TreeTops are used to
determine program order.

Separately a Control Flow Graph is maintained which links the blocks in a graph.
The user must set up the graph edges depending on control flow. JIT_BlockRefs
are of type JIT_CFGNodeRef. Some api calls will automatically add the
appropriate edge. See usage notes below for when you need to add your own.

The IL requires that for a Node to be accessed in a Block other than where
it was created, the Node must have be stored in the block that created it.
*/

typedef struct JIT_Node *JIT_NodeRef;
typedef struct JIT_TreeTop *JIT_TreeTopRef;
typedef struct JIT_Block *JIT_BlockRef;
typedef struct JIT_CFGNode *JIT_CFGNodeRef; // Note that Blocks are CFGNodes
typedef struct JIT_Symbol *JIT_SymbolRef;

/**
 * Generate IL and compile the function. To generate IL the user supplied
 * JIT_ILBuilder callback will be invoked. If that succeeds then the
 * function will be compiled.
 *
 * opt_level controls optimizations.
 * 0 = no opt
 * 1 = warm
 * 2 = hot
 *
 * This function returns pointer to compiled code on success
 * Or else a NULL is returned.
 */
extern void *JIT_Compile(JIT_FunctionBuilderRef fb, int opt_level);

/**
 * Allocates given number of blocks, and leaves the current block pointer
 * at 0. The CFG starting edge is made to point to Node 0.
 */
extern void JIT_CreateBlocks(JIT_ILInjectorRef ilinjector, int32_t num);

/**
 * Makes the given block number the current block. This must be done
 * prior to generating any IL.
 */
extern void JIT_SetCurrentBlock(JIT_ILInjectorRef ilinjector, int32_t b);

/**
 * Gets the current block
 */
extern JIT_BlockRef JIT_GetCurrentBlock(JIT_ILInjectorRef ilinjector);

/**
 * Gets the specified block
 */
extern JIT_BlockRef JIT_GetBlock(JIT_ILInjectorRef ilinjector, int32_t b);

/**
 * Create various constants
 */
extern JIT_NodeRef JIT_ConstInt32(int32_t i);
extern JIT_NodeRef JIT_ConstInt64(int64_t i);
extern JIT_NodeRef JIT_ConstInt16(int16_t i);
extern JIT_NodeRef JIT_ConstInt8(int8_t i);
extern JIT_NodeRef JIT_ConstFloat(float value);
extern JIT_NodeRef JIT_ConstDouble(double value);
extern JIT_NodeRef JIT_ConstAddress(void *value);
extern JIT_NodeRef JIT_ConstUInt32(uint32_t i);
extern JIT_NodeRef JIT_ConstUInt64(uint64_t i);
extern JIT_NodeRef JIT_ConstUInt8(uint8_t i);
extern JIT_NodeRef JIT_ZeroValue(JIT_ILInjectorRef ilinjector, JIT_Type type);

/**
 * Gets the Node's type
 */
extern JIT_Type JIT_GetNodeType(JIT_NodeRef node);

/**
 * Node opcodes - See the JIT_CreateNode*() family of
 * functions. Note that some opcodes need 1 or more child nodes,
 * this is indicated in the comment that follows each enum
 * value.
 */
enum JIT_NodeOpCode {
  OP_BadILOp = 0, // illegal op hopefully help with uninitialised nodes
  OP_aconst,      // load address constant (zero value means NULL)
  OP_iconst,      // load integer constant (32-bit signed 2's complement)
  OP_lconst,      // load long integer constant (64-bit signed 2's complement)
  OP_fconst,      // load float constant (32-bit ieee fp)
  OP_dconst,      // load double constant (64-bit ieee fp)
  OP_bconst,      // load byte integer constant (8-bit signed 2's complement)
  OP_sconst,      // load short integer constant (16-bit signed 2's complement)
  OP_iload,       // load integer
  OP_fload,       // load float
  OP_dload,       // load double
  OP_aload,       // load address
  OP_bload,       // load byte
  OP_sload,       // load short integer
  OP_lload,       // load long integer
  //Read barrier is used to represent loads with side effects like check for GC, debugging etc.
  //It is the same as the corresponding load except that it needs to be anchored under a
  //treetop. The children and symbol of a read barrier are the same as the corresponding load.
  OP_irdbar,   // read barrier for load integer
  OP_frdbar,   // read barrier for load float
  OP_drdbar,   // read barrier for load double
  OP_ardbar,   // read barrier for load address
  OP_brdbar,   // read barrier for load byte
  OP_srdbar,   // load short integer
  OP_lrdbar,   // load long integer
  OP_iloadi,      // load indirect integer
  OP_floadi,      // load indirect float
  OP_dloadi,      // load indirect double
  OP_aloadi,      // load indirect address
  OP_bloadi,      // load indirect byte
  OP_sloadi,      // load indirect short integer
  OP_lloadi,      // load indirect long integer
  OP_irdbari,  // read barrier for load indirect integer
  OP_frdbari,  // read barrier for load indirect float
  OP_drdbari,  // read barrier for load indirect double
  OP_ardbari,  // read barrier for load indirect address
  OP_brdbari,  // read barrier for load indirect byte
  OP_srdbari,  // read barrier for load indirect short integer
  OP_lrdbari,  // read barrier for load indirect long integer
  OP_istore,      // store integer
  OP_lstore,      // store long integer
  OP_fstore,      // store float
  OP_dstore,      // store double
  OP_astore,      // store address
  OP_bstore,  // store byte
  OP_sstore,  // store short integer
   // direct write barrier represent both the write and side effects of
   // the write like checks for GC, debugging etc.
   //
   // In case of GC checks, write barrier checks for new space in old
   // space reference store. The first child is the value as in astore.
   // The second child is the address of the object that must be checked
   // for old space the symbol reference holds addresses, flags and offsets
   // as in astore
  OP_iwrtbar,  // write barrier for store direct integer
  OP_lwrtbar,  // write barrier for store direct long integer
  OP_fwrtbar,  // write barrier for store direct float
  OP_dwrtbar,  // write barrier for store direct double
  OP_awrtbar,  // write barrier for store direct address
  OP_bwrtbar,  // write barrier for store direct byte
  OP_swrtbar,  // write barrier for store direct short integer

  OP_lstorei, // store indirect long integer           (child1 a, child2 l)
  OP_fstorei, // store indirect float                  (child1 a, child2 f)
  OP_dstorei, // store indirect double                 (child1 a, child2 d)
  OP_astorei, // store indirect address                (child1 a dest, child2 a
              // value)
  OP_bstorei,    // store indirect byte                   (child1 a, child2 b)
  OP_sstorei,    // store indirect short integer          (child1 a, child2 s)
  OP_istorei,    // store indirect integer                (child1 a, child2 i)
   // indirect write barrier represent both the write and side effects of
   // the write like checks for GC, debugging etc.
   //
   // In case of GC checks, indirect write barrier store checks for new space
   // in old space reference store.
   // The first two children are as in astorei.  The third child is address
   // of the beginning of the destination object.  For putfield this will often
   // be the same as the first child (when the offset is on the symbol reference.
   // But for array references, children 1 and 3 will be quite different although
   // child 1's subtree will contain a reference to child 3's subtree
  OP_lwrtbari, // write barrier for store indirect long integer
  OP_fwrtbari, // write barrier for store indirect float
  OP_dwrtbari, // write barrier for store indirect double
  OP_awrtbari, // write barrier for store indirect address
  OP_bwrtbari, // write barrier for store indirect byte
  OP_swrtbari, // write barrier for store indirect short integer
  OP_iwrtbari, // write barrier for store indirect integer
  OP_Goto,       // goto label address
  OP_ireturn,    // return an integer
  OP_lreturn,    // return a long integer
  OP_freturn,    // return a float
  OP_dreturn,    // return a double
  OP_areturn,    // return an address
  OP_Return,     // void return
  OP_asynccheck, // GC point
  OP_athrow,     // throw an exception
  OP_icall,      // direct call returning integer
  OP_lcall,      // direct call returning long integer
  OP_fcall,      // direct call returning float
  OP_dcall,      // direct call returning double
  OP_acall,      // direct call returning reference
  OP_call,       // direct call returning void
  OP_iadd,       // add 2 integers
  OP_ladd,       // add 2 long integers
  OP_fadd,       // add 2 floats
  OP_dadd,       // add 2 doubles
  OP_badd,       // add 2 bytes
  OP_sadd,       // add 2 short integers
  OP_isub,       // subtract 2 integers                (child1 - child2)
  OP_lsub,       // subtract 2 long integers           (child1 - child2)
  OP_fsub,       // subtract 2 floats                  (child1 - child2)
  OP_dsub,       // subtract 2 doubles                 (child1 - child2)
  OP_bsub,       // subtract 2 bytes                   (child1 - child2)
  OP_ssub,       // subtract 2 short integers          (child1 - child2)
  OP_asub,       // subtract 2 addresses (child1 - child2)
  OP_imul,       // multiply 2 integers
  OP_lmul,       // multiply 2 signed or unsigned long integers
  OP_fmul,       // multiply 2 floats
  OP_dmul,       // multiply 2 doubles
  OP_bmul,       // multiply 2 bytes
  OP_smul,       // multiply 2 short integers
  OP_iumul,      // multiply 2 unsigned integers
  OP_idiv,       // divide 2 integers                (child1 / child2)
  OP_ldiv,       // divide 2 long integers           (child1 / child2)
  OP_fdiv,       // divide 2 floats                  (child1 / child2)
  OP_ddiv,       // divide 2 doubles                 (child1 / child2)
  OP_bdiv,       // divide 2 bytes                   (child1 / child2)
  OP_sdiv,       // divide 2 short integers          (child1 / child2)
  OP_iudiv,      // divide 2 unsigned integers       (child1 / child2)
  OP_ludiv,      // divide 2 unsigned long integers  (child1 / child2)
  OP_irem,       // remainder of 2 integers                (child1 % child2)
  OP_lrem,       // remainder of 2 long integers           (child1 % child2)
  OP_frem,       // remainder of 2 floats                  (child1 % child2)
  OP_drem,       // remainder of 2 doubles                 (child1 % child2)
  OP_brem,       // remainder of 2 bytes                   (child1 % child2)
  OP_srem,       // remainder of 2 short integers          (child1 % child2)
  OP_iurem,      // remainder of 2 unsigned integers       (child1 % child2)
  OP_ineg,       // negate an integer
  OP_lneg,       // negate a long integer
  OP_fneg,       // negate a float
  OP_dneg,       // negate a double
  OP_bneg,       // negate a bytes
  OP_sneg,       // negate a short integer
  OP_iabs,       // absolute value of integer
  OP_labs,       // absolute value of long
  OP_fabs,       // absolute value of float
  OP_dabs,       // absolute value of double
  OP_ishl,       // shift integer left                (child1 << child2)
  OP_lshl,       // shift long integer left           (child1 << child2)
  OP_bshl,       // shift byte left                   (child1 << child2)
  OP_sshl,       // shift short integer left          (child1 << child2)
  OP_ishr,       // shift integer right arithmetically               (child1 >>
                 // child2)
  OP_lshr,       // shift long integer right arithmetically          (child1 >>
                 // child2)
  OP_bshr,       // shift byte right arithmetically                  (child1 >>
                 // child2)
  OP_sshr,       // shift short integer arithmetically               (child1 >>
                 // child2)
  OP_iushr,      // shift integer right logically                   (child1 >>
                 // child2)
  OP_lushr,      // shift long integer right logically              (child1 >>
                 // child2)
  OP_bushr,      // shift byte right logically                      (child1 >>
                 // child2)
  OP_sushr,      // shift short integer right logically             (child1 >>
                 // child2)
  OP_irol,       // rotate integer left
  OP_lrol,       // rotate long integer left
  OP_iand,       // boolean and of 2 integers
  OP_land,       // boolean and of 2 long integers
  OP_band,       // boolean and of 2 bytes
  OP_sand,       // boolean and of 2 short integers
  OP_ior,        // boolean or of 2 integers
  OP_lor,        // boolean or of 2 long integers
  OP_bor,        // boolean or of 2 bytes
  OP_sor,        // boolean or of 2 short integers
  OP_ixor,       // boolean xor of 2 integers
  OP_lxor,       // boolean xor of 2 long integers
  OP_bxor,       // boolean xor of 2 bytes
  OP_sxor,       // boolean xor of 2 short integers

  OP_i2l, // convert integer to long integer with sign extension
  OP_i2f, // convert integer to float
  OP_i2d, // convert integer to double
  OP_i2b, // convert integer to byte
  OP_i2s, // convert integer to short integer
  OP_i2a, // convert integer to address

  OP_iu2l, // convert unsigned integer to long integer with zero extension
  OP_iu2f, // convert unsigned integer to float
  OP_iu2d, // convert unsigned integer to double
  OP_iu2a, // convert unsigned integer to address

  OP_l2i, // convert long integer to integer
  OP_l2f, // convert long integer to float
  OP_l2d, // convert long integer to double
  OP_l2b, // convert long integer to byte
  OP_l2s, // convert long integer to short integer
  OP_l2a, // convert long integer to address

  OP_lu2f, // convert unsigned long integer to float
  OP_lu2d, // convert unsigned long integer to double
  OP_lu2a, // convert unsigned long integer to address

  OP_f2i, // convert float to integer
  OP_f2l, // convert float to long integer
  OP_f2d, // convert float to double
  OP_f2b, // convert float to byte
  OP_f2s, // convert float to short integer

  OP_d2i, // convert double to integer
  OP_d2l, // convert double to long integer
  OP_d2f, // convert double to float
  OP_d2b, // convert double to byte
  OP_d2s, // convert double to short integer

  OP_b2i, // convert byte to integer with sign extension
  OP_b2l, // convert byte to long integer with sign extension
  OP_b2f, // convert byte to float
  OP_b2d, // convert byte to double
  OP_b2s, // convert byte to short integer with sign extension
  OP_b2a, // convert byte to address

  OP_bu2i, // convert byte to integer with zero extension
  OP_bu2l, // convert byte to long integer with zero extension
  OP_bu2f, // convert unsigned byte to float
  OP_bu2d, // convert unsigned byte to double
  OP_bu2s, // convert byte to short integer with zero extension
  OP_bu2a, // convert unsigned byte to unsigned address

  OP_s2i, // convert short integer to integer with sign extension
  OP_s2l, // convert short integer to long integer with sign extension
  OP_s2f, // convert short integer to float
  OP_s2d, // convert short integer to double
  OP_s2b, // convert short integer to byte
  OP_s2a, // convert short integer to address

  OP_su2i, // zero extend short to int
  OP_su2l, // zero extend char to long
  OP_su2f, // convert char to float
  OP_su2d, // convert char to double
  OP_su2a, // convert char to address

  OP_a2i,     // convert address to integer
  OP_a2l,     // convert address to long integer
  OP_a2b,     // convert address to byte
  OP_a2s,     // convert address to short
  OP_icmpeq,  // integer compare if equal
  OP_icmpne,  // integer compare if not equal
  OP_icmplt,  // integer compare if less than
  OP_icmpge,  // integer compare if greater than or equal
  OP_icmpgt,  // integer compare if greater than
  OP_icmple,  // integer compare if less than or equal
  OP_iucmpeq, // unsigned integer compare if equal
  OP_iucmpne, // unsigned integer compare if not equal
  OP_iucmplt, // unsigned integer compare if less than
  OP_iucmpge, // unsigned integer compare if greater than or equal
  OP_iucmpgt, // unsigned integer compare if greater than
  OP_iucmple, // unsigned integer compare if less than or equal
  OP_lcmpeq,  // long compare if equal
  OP_lcmpne,  // long compare if not equal
  OP_lcmplt,  // long compare if less than
  OP_lcmpge,  // long compare if greater than or equal
  OP_lcmpgt,  // long compare if greater than
  OP_lcmple,  // long compare if less than or equal
  OP_lucmpeq, // unsigned long compare if equal
  OP_lucmpne, // unsigned long compare if not equal
  OP_lucmplt, // unsigned long compare if less than
  OP_lucmpge, // unsigned long compare if greater than or equal
  OP_lucmpgt, // unsigned long compare if greater than
  OP_lucmple, // unsigned long compare if less than or equal
  OP_fcmpeq,  // float compare if equal
  OP_fcmpne,  // float compare if not equal
  OP_fcmplt,  // float compare if less than
  OP_fcmpge,  // float compare if greater than or equal
  OP_fcmpgt,  // float compare if greater than
  OP_fcmple,  // float compare if less than or equal
  OP_fcmpequ, // float compare if equal or unordered
  OP_fcmpneu, // float compare if not equal or unordered
  OP_fcmpltu, // float compare if less than or unordered
  OP_fcmpgeu, // float compare if greater than or equal or unordered
  OP_fcmpgtu, // float compare if greater than or unordered
  OP_fcmpleu, // float compare if less than or equal or unordered
  OP_dcmpeq,  // double compare if equal
  OP_dcmpne,  // double compare if not equal
  OP_dcmplt,  // double compare if less than
  OP_dcmpge,  // double compare if greater than or equal
  OP_dcmpgt,  // double compare if greater than
  OP_dcmple,  // double compare if less than or equal
  OP_dcmpequ, // double compare if equal or unordered
  OP_dcmpneu, // double compare if not equal or unordered
  OP_dcmpltu, // double compare if less than or unordered
  OP_dcmpgeu, // double compare if greater than or equal or unordered
  OP_dcmpgtu, // double compare if greater than or unordered
  OP_dcmpleu, // double compare if less than or equal or unordered
  OP_acmpeq,  // address compare if equal
  OP_acmpne,  // address compare if not equal
  OP_acmplt,  // address compare if less than
  OP_acmpge,  // address compare if greater than or equal
  OP_acmpgt,  // address compare if greater than
  OP_acmple,  // address compare if less than or equal
  OP_bcmpeq,  // byte compare if equal
  OP_bcmpne,  // byte compare if not equal
  OP_bcmplt,  // byte compare if less than
  OP_bcmpge,  // byte compare if greater than or equal
  OP_bcmpgt,  // byte compare if greater than
  OP_bcmple,  // byte compare if less than or equal
  OP_bucmpeq, // unsigned byte compare if equal
  OP_bucmpne, // unsigned byte compare if not equal
  OP_bucmplt, // unsigned byte compare if less than
  OP_bucmpge, // unsigned byte compare if greater than or equal
  OP_bucmpgt, // unsigned byte compare if greater than
  OP_bucmple, // unsigned byte compare if less than or equal
  OP_scmpeq,  // short integer compare if equal
  OP_scmpne,  // short integer compare if not equal
  OP_scmplt,  // short integer compare if less than
  OP_scmpge,  // short integer compare if greater than or equal
  OP_scmpgt,  // short integer compare if greater than
  OP_scmple,  // short integer compare if less than or equal
  OP_sucmpeq, // char compare if equal
  OP_sucmpne, // char compare if not equal
  OP_sucmplt, // char compare if less than
  OP_sucmpge, // char compare if greater than or equal
  OP_sucmpgt, // char compare if greater than
  OP_sucmple, // char compare if less than or equal
  OP_lcmp,  // long compare (1 if child1 > child2, 0 if child1 == child2, -1 if
            // child1 < child2)
  OP_fcmpl, // float compare l (1 if child1 > child2, 0 if child1 == child2, -1
            // if
            // child1 < child2 or unordered)
  OP_fcmpg, // float compare g (1 if child1 > child2 or unordered, 0 if child1
            // ==
            // child2, -1 if child1 < child2)
  OP_dcmpl, // double compare l (1 if child1 > child2, 0 if child1 == child2, -1
            // if
            // child1 < child2 or unordered)
  OP_dcmpg, // double compare g (1 if child1 > child2 or unordered, 0 if child1
            // ==
            // child2, -1 if child1 < child2)
  OP_ificmpeq,  // integer compare and branch if equal
  OP_ificmpne,  // integer compare and branch if not equal
  OP_ificmplt,  // integer compare and branch if less than
  OP_ificmpge,  // integer compare and branch if greater than or equal
  OP_ificmpgt,  // integer compare and branch if greater than
  OP_ificmple,  // integer compare and branch if less than or equal
  OP_ifiucmpeq, // unsigned integer compare and branch if equal
  OP_ifiucmpne, // unsigned integer compare and branch if not equal
  OP_ifiucmplt, // unsigned integer compare and branch if less than
  OP_ifiucmpge, // unsigned integer compare and branch if greater than or equal
  OP_ifiucmpgt, // unsigned integer compare and branch if greater than
  OP_ifiucmple, // unsigned integer compare and branch if less than or equal
  OP_iflcmpeq,  // long compare and branch if equal
  OP_iflcmpne,  // long compare and branch if not equal
  OP_iflcmplt,  // long compare and branch if less than
  OP_iflcmpge,  // long compare and branch if greater than or equal
  OP_iflcmpgt,  // long compare and branch if greater than
  OP_iflcmple,  // long compare and branch if less than or equal
  OP_iflucmpeq, // unsigned long compare and branch if equal
  OP_iflucmpne, // unsigned long compare and branch if not equal
  OP_iflucmplt, // unsigned long compare and branch if less than
  OP_iflucmpge, // unsigned long compare and branch if greater than or equal
  OP_iflucmpgt, // unsigned long compare and branch if greater than
  OP_iflucmple, // unsigned long compare and branch if less than or equal
  OP_iffcmpeq,  // float compare and branch if equal
  OP_iffcmpne,  // float compare and branch if not equal
  OP_iffcmplt,  // float compare and branch if less than
  OP_iffcmpge,  // float compare and branch if greater than or equal
  OP_iffcmpgt,  // float compare and branch if greater than
  OP_iffcmple,  // float compare and branch if less than or equal
  OP_iffcmpequ, // float compare and branch if equal or unordered
  OP_iffcmpneu, // float compare and branch if not equal or unordered
  OP_iffcmpltu, // float compare and branch if less than or unordered
  OP_iffcmpgeu, // float compare and branch if greater than or equal or
                // unordered
  OP_iffcmpgtu, // float compare and branch if greater than or unordered
  OP_iffcmpleu, // float compare and branch if less than or equal or unordered
  OP_ifdcmpeq,  // double compare and branch if equal
  OP_ifdcmpne,  // double compare and branch if not equal
  OP_ifdcmplt,  // double compare and branch if less than
  OP_ifdcmpge,  // double compare and branch if greater than or equal
  OP_ifdcmpgt,  // double compare and branch if greater than
  OP_ifdcmple,  // double compare and branch if less than or equal
  OP_ifdcmpequ, // double compare and branch if equal or unordered
  OP_ifdcmpneu, // double compare and branch if not equal or unordered
  OP_ifdcmpltu, // double compare and branch if less than or unordered
  OP_ifdcmpgeu, // double compare and branch if greater than or equal or
                // unordered
  OP_ifdcmpgtu, // double compare and branch if greater than or unordered
  OP_ifdcmpleu, // double compare and branch if less than or equal or unordered
  OP_ifacmpeq,  // address compare and branch if equal
  OP_ifacmpne,  // address compare and branch if not equal
  OP_ifacmplt,  // address compare and branch if less than
  OP_ifacmpge,  // address compare and branch if greater than or equal
  OP_ifacmpgt,  // address compare and branch if greater than
  OP_ifacmple,  // address compare and branch if less than or equal
  OP_ifbcmpeq,  // byte compare and branch if equal
  OP_ifbcmpne,  // byte compare and branch if not equal
  OP_ifbcmplt,  // byte compare and branch if less than
  OP_ifbcmpge,  // byte compare and branch if greater than or equal
  OP_ifbcmpgt,  // byte compare and branch if greater than
  OP_ifbcmple,  // byte compare and branch if less than or equal
  OP_ifbucmpeq, // unsigned byte compare and branch if equal
  OP_ifbucmpne, // unsigned byte compare and branch if not equal
  OP_ifbucmplt, // unsigned byte compare and branch if less than
  OP_ifbucmpge, // unsigned byte compare and branch if greater than or equal
  OP_ifbucmpgt, // unsigned byte compare and branch if greater than
  OP_ifbucmple, // unsigned byte compare and branch if less than or equal
  OP_ifscmpeq,  // short integer compare and branch if equal
  OP_ifscmpne,  // short integer compare and branch if not equal
  OP_ifscmplt,  // short integer compare and branch if less than
  OP_ifscmpge,  // short integer compare and branch if greater than or equal
  OP_ifscmpgt,  // short integer compare and branch if greater than
  OP_ifscmple,  // short integer compare and branch if less than or equal
  OP_ifsucmpeq, // char compare and branch if equal
  OP_ifsucmpne, // char compare and branch if not equal
  OP_ifsucmplt, // char compare and branch if less than
  OP_ifsucmpge, // char compare and branch if greater than or equal
  OP_ifsucmpgt, // char compare and branch if greater than
  OP_ifsucmple, // char compare and branch if less than or equal
  OP_loadaddr,  // load address of non-heap storage item (Auto, Parm, Static or
                // Method)
  OP_ZEROCHK, // Zero-check an int.  Symref indicates call to perform when first
              // child is zero.  Other children are arguments to the call.
  OP_callIf,  // Call symref if first child evaluates to true.  Other childrem
              // are
              // arguments to the call.
  OP_iRegLoad,  // Load integer global register
  OP_aRegLoad,  // Load address global register
  OP_lRegLoad,  // Load long integer global register
  OP_fRegLoad,  // Load float global register
  OP_dRegLoad,  // Load double global register
  OP_sRegLoad,  // Load short global register
  OP_bRegLoad,  // Load byte global register
  OP_iRegStore, // Store integer global register
  OP_aRegStore, // Store address global register
  OP_lRegStore, // Store long integer global register
  OP_fRegStore, // Store float global register
  OP_dRegStore, // Store double global register
  OP_sRegStore, // Store short global register
  OP_bRegStore, // Store byte global register
  OP_GlRegDeps, // Global Register Dependency List
  OP_iternary,  // Ternary Operator:  Based on the result of the first child,
                // take
                // the value of the
  OP_lternary,  //   second (first child evaluates to true) or third(first child
                //   evaluates to false) child
  OP_bternary,  //
  OP_sternary,  //
  OP_aternary,  //
  OP_fternary,  //
  OP_dternary,  //
  OP_treetop,   // tree top to anchor subtrees with side-effects
  OP_MethodEnterHook, // called after a frame is built, temps initialized, and
                      // monitor acquired (if necessary)
  OP_MethodExitHook,  // called immediately before returning, frame not yet
                      // collapsed, monitor released (if necessary)
  OP_PassThrough,     // Dummy node that represents its single child.
  OP_compressedRefs,  // no-op anchor providing optimizable subexpressions used
                      // for compression/decompression.  First child is address
                      // load/store, second child is heap base displacement
  OP_BBStart,         // Start of Basic Block
  OP_BBEnd,           // End of Basic Block

  OP_virem,     // vector integer remainder
  OP_vimin,     // vector integer minimum
  OP_vimax,     // vector integer maximum
  OP_vigetelem, // get vector int element
  OP_visetelem, // set vector int element
  OP_vimergel,  // vector int merge low
  OP_vimergeh,  // vector int merge high

  OP_vicmpeq, // vector integer compare equal  (return vector mask)
  OP_vicmpgt, // vector integer compare greater than
  OP_vicmpge, // vector integer compare greater equal
  OP_vicmplt, // vector integer compare less than
  OP_vicmple, // vector integer compare less equal

  OP_vicmpalleq, // vector integer all equal (return boolean)
  OP_vicmpallne, // vector integer all not equal
  OP_vicmpallgt, // vector integer all greater than
  OP_vicmpallge, // vector integer all greater equal
  OP_vicmpalllt, // vector integer all less than
  OP_vicmpallle, // vector integer all less equal
  OP_vicmpanyeq, // vector integer any equal
  OP_vicmpanyne, // vector integer any not equal
  OP_vicmpanygt, // vector integer any greater than
  OP_vicmpanyge, // vector integer any greater equal
  OP_vicmpanylt, // vector integer any less than
  OP_vicmpanyle, // vector integer any less equal

  OP_vnot,    // vector boolean not
  OP_vselect, // vector select
  OP_vperm,   // vector permute

  OP_vsplats,   // vector splats
  OP_vdmergel,  // vector double merge low
  OP_vdmergeh,  // vector double merge high
  OP_vdsetelem, // set vector double element
  OP_vdgetelem, // get vector double element
  OP_vdsel,     // get vector select double

  OP_vdrem,   // vector double remainder
  OP_vdmadd,  // vector double fused multiply add
  OP_vdnmsub, // vector double fused negative multiply subtract
  OP_vdmsub,  // vector double fused multiply subtract
  OP_vdmax,   // vector double maximum
  OP_vdmin,   // vector double minimum

  OP_vdcmpeq, // vector double compare equal  (return vector mask)
  OP_vdcmpne, // vector double compare not equal  (return vector mask)
  OP_vdcmpgt, // vector double compare greater than
  OP_vdcmpge, // vector double compare greater equal
  OP_vdcmplt, // vector double compare less than
  OP_vdcmple, // vector double compare less equal

  OP_vdcmpalleq, // vector double compare all equal  (return boolean)
  OP_vdcmpallne, // vector double compare all not equal  (return boolean)
  OP_vdcmpallgt, // vector double compare all greater than
  OP_vdcmpallge, // vector double compare all greater equal
  OP_vdcmpalllt, // vector double compare all less than
  OP_vdcmpallle, // vector double compare all less equal

  OP_vdcmpanyeq, // vector double compare any equal  (return boolean)
  OP_vdcmpanyne, // vector double compare any not equal  (return boolean)
  OP_vdcmpanygt, // vector double compare any greater than
  OP_vdcmpanyge, // vector double compare any greater equal
  OP_vdcmpanylt, // vector double compare any less than
  OP_vdcmpanyle, // vector double compare any less equal
  OP_vdsqrt,     // vector double square root
  OP_vdlog,      // vector double natural log

  /* Begin general vector opcodes */
  OP_vinc,     // vector increment
  OP_vdec,     // vector decrement
  OP_vneg,     // vector negation
  OP_vcom,     // vector complement
  OP_vadd,     // vector add
  OP_vsub,     // vector subtract
  OP_vmul,     // vector multiply
  OP_vdiv,     // vector divide
  OP_vrem,     // vector remainder
  OP_vand,     // vector logical AND
  OP_vor,      // vector logical OR
  OP_vxor,     // vector exclusive OR integer
  OP_vshl,     // vector shift left
  OP_vushr,    // vector shift right logical
  OP_vshr,     // vector shift right arithmetic
  OP_vcmpeq,   // vector compare equal
  OP_vcmpne,   // vector compare not equal
  OP_vcmplt,   // vector compare less than
  OP_vucmplt,  // vector unsigned compare less than
  OP_vcmpgt,   // vector compare greater than
  OP_vucmpgt,  // vector unsigned compare greater than
  OP_vcmple,   // vector compare less or equal
  OP_vucmple,  // vector unsigned compare less or equal
  OP_vcmpge,   // vector compare greater or equal
  OP_vucmpge,  // vector unsigned compare greater or equal
  OP_vload,    // load vector
  OP_vloadi,   // load indirect vector
  OP_vstore,   // store vector
  OP_vstorei,  // store indirect vector
  OP_vrand,    // AND all elements into single value of element size
  OP_vreturn,  // return a vector
  OP_vcall,    // direct call returning a vector
  OP_vcalli,   // indirect call returning a vector
  OP_vternary, // vector ternary operator
  OP_v2v,   // vector to vector conversion. preserves bit pattern (noop), only
            // changes datatype
  OP_vl2vd, // vector to vector conversion. converts each long element to double
  OP_vconst,   // vector constant
  OP_getvelem, // get vector element, returns a scalar
  OP_vsetelem, // vector set element

  OP_vbRegLoad,  // Load vector global register
  OP_vsRegLoad,  // Load vector global register
  OP_viRegLoad,  // Load vector global register
  OP_vlRegLoad,  // Load vector global register
  OP_vfRegLoad,  // Load vector global register
  OP_vdRegLoad,  // Load vector global register
  OP_vbRegStore, // Store vector global register
  OP_vsRegStore, // Store vector global register
  OP_viRegStore, // Store vector global register
  OP_vlRegStore, // Store vector global register
  OP_vfRegStore, // Store vector global register
  OP_vdRegStore, // Store vector global register

  OP_iuconst,    // load unsigned integer constant (32-but unsigned)
  OP_luconst,    // load unsigned long integer constant (64-bit unsigned)
  OP_buconst,    // load unsigned byte integer constant (8-bit unsigned)
  OP_iuload,     // load unsigned integer
  OP_luload,     // load unsigned long integer
  OP_buload,     // load unsigned byte
  OP_iuloadi,    // load indirect unsigned integer
  OP_luloadi,    // load indirect unsigned long integer
  OP_buloadi,    // load indirect unsigned byte
  OP_iustore,    // store unsigned integer
  OP_lustore,    // store unsigned long integer
  OP_bustore,    // store unsigned byte
  OP_iustorei,   // store indirect unsigned integer       (child1 a, child2 i)
  OP_lustorei,   // store indirect unsigned long integer  (child1 a, child2 l)
  OP_bustorei,   // store indirect unsigned byte          (child1 a, child2 b)
  OP_iureturn,   // return an unsigned integer
  OP_lureturn,   // return a long unsigned integer
  OP_iucall,     // direct call returning unsigned integer
  OP_lucall,     // direct call returning unsigned long integer
  OP_iuadd,      // add 2 unsigned integers
  OP_luadd,      // add 2 unsigned long integers
  OP_buadd,      // add 2 unsigned bytes
  OP_iusub,      // subtract 2 unsigned integers       (child1 - child2)
  OP_lusub,      // subtract 2 unsigned long integers  (child1 - child2)
  OP_busub,      // subtract 2 unsigned bytes          (child1 - child2)
  OP_iuneg,      // negate an unsigned integer
  OP_luneg,      // negate a unsigned long integer
  OP_iushl,      // shift unsigned integer left       (child1 << child2)
  OP_lushl,      // shift unsigned long integer left  (child1 << child2)
  OP_f2iu,       // convert float to unsigned integer
  OP_f2lu,       // convert float to unsigned long integer
  OP_f2bu,       // convert float to unsigned byte
  OP_f2c,        // convert float to char
  OP_d2iu,       // convert double to unsigned integer
  OP_d2lu,       // convert double to unsigned long integer
  OP_d2bu,       // convert double to unsigned byte
  OP_d2c,        // convert double to char
  OP_iuRegLoad,  // Load unsigned integer global register
  OP_luRegLoad,  // Load unsigned long integer global register
  OP_iuRegStore, // Store unsigned integer global register
  OP_luRegStore, // Store long integer global register
  OP_iuternary, // second or the third child.  Analogous to the "condition ? a :
                // b"
                // operations in C/Java.
  OP_luternary, //
  OP_buternary, //
  OP_suternary, //
  OP_cconst,    // load unicode constant (16-bit unsigned)
  OP_cload,     // load short unsigned integer
  OP_cloadi,    // load indirect unsigned short integer
  OP_cstore,    // store unsigned short integer
  OP_cstorei,   // store indirect unsigned short integer (child1 a, child2 c)
  OP_monent,    // acquire lock for synchronising method
  OP_monexit,   // release lock for synchronising method
  OP_monexitfence, // denotes the end of a monitored region solely for live
                   // monitor
                   // meta data
  OP_tstart,       // transaction begin
  OP_tfinish,      // transaction end
  OP_tabort,       // transaction abort
  OP_instanceof, // instanceof - symref is the class object, cp index is in the
                 // "int" field, child is the object reference
  OP_checkcast,  // checkcast
  OP_checkcastAndNULLCHK, // checkcast and NULL check the underlying object
                          // reference
  OP_New,                 // new - child is class
  OP_newarray,            // new array of primitives
  OP_anewarray,           // new array of objects
  OP_variableNew,       // new - child is class, type not known at compile time
  OP_variableNewArray,  // new array - type not known at compile time, type must
                        // be
                        // a j9class, do not use type enums
  OP_multianewarray,    // multi-dimensional new array of objects
  OP_arraylength,       // number of elements in an array
  OP_contigarraylength, // number of elements in a contiguous array
  OP_discontigarraylength, // number of elements in a discontiguous array
  OP_icalli,  // indirect call returning integer (child1 is addr of function)
  OP_iucalli, // indirect call returning unsigned integer (child1 is addr of
              // function)
  OP_lcalli,  // indirect call returning long integer (child1 is addr of
              // function)
  OP_lucalli, // indirect call returning unsigned long integer (child1 is addr
              // of
              // function)
  OP_fcalli,  // indirect call returning float (child1 is addr of function)
  OP_dcalli,  // indirect call returning double (child1 is addr of function)
  OP_acalli,  // indirect call returning reference
  OP_calli,   // indirect call returning void (child1 is addr of function)
  OP_fence,   // barrier to optimization
  OP_luaddh,  // add 2 unsigned long integers (the high parts of prior luadd) as
              // high part of 128bit addition.
  OP_cadd,    // add 2 unsigned short integers
  OP_aiadd,   // add integer to address with address result (child1 a, child2 i)
  OP_aiuadd,  // add unsigned integer to address with address result (child1 a,
              // child2 i)
  OP_aladd, // add long integer to address with address result (child1 a, child2
            // i)
            // (64-bit only)
  OP_aluadd, // add unsigned long integer to address with address result (child1
             // a,
             // child2 i) (64-bit only)
  OP_lusubh, // subtract 2 unsigned long integers (the high parts of prior
             // lusub)
             // as high part of 128bit subtraction.
  OP_csub,   // subtract 2 unsigned short integers (child1 - child2)
  OP_imulh,  // multiply 2 integers, and return the high word of the product
  OP_iumulh, // multiply 2 unsigned integers, and return the high word of the
             // product
  OP_lmulh, // multiply 2 long integers, and return the high word of the product
  OP_lumulh,  // multiply 2 unsigned long integers, and return the high word of
              // the
              // product
  OP_ibits2f, // type-coerce int to float
  OP_fbits2i, // type-coerce float to int
  OP_lbits2d, // type-coerce long to double
  OP_dbits2l, // type-coerce double to long
  OP_lookup,  // lookupswitch (child1 is selector expression, child2 the default
              // destination, subsequent children are case nodes
  OP_trtLookup, // special lookupswitch (child1 must be trt, child2 the default
                // destination, subsequent children are case nodes) The internal
                // control flow is similar to lookup, but each CASE represents a
                // special semantics associated with a flag on it
  OP_Case,      // case nodes that are children of TR_switch.  Uses the
                // branchdestination and the int const field
  OP_table,     // tableswitch (child1 is the selector, child2 the default
                // destination,
  // subsequent children are the branch targets (the last child may be a
  // branch table address, use getCaseIndexUpperBound() when iterating
  // over branch targets)
  OP_exceptionRangeFence, // (J9) SymbolReference is the aliasing effect,
                          // initialiser is where the code address gets put when
  // binary is generated used for delimiting function, try
  // blocks, catch clauses, finally clauses, etc.
  OP_dbgFence, // used to delimit code (stmts) for debug info.  Has no symbol
               // reference.
  OP_NULLCHK, // Null check a pointer.  child 1 is indirect reference. Symbolref
              // indicates failure action/destination
  OP_ResolveCHK, // Resolve check a static, field or method. child 1 is
                 // reference
  // to be resolved. Symbolref indicates failure action/destination
  OP_ResolveAndNULLCHK, // Resolve check a static, field or method and Null
                        // check
                        // the underlying pointer.  child 1 is reference to be
  // resolved. Symbolref indicates failure action/destination
  OP_DIVCHK, // Divide by zero check. child 1 is the divide. Symbolref indicates
             // failure action/destination
  OP_OverflowCHK, // Overflow check. child 1 is the operation node(add, mul,
                  // sub).
  // Child 2 and child 3 are the operands of the operation of the
  // operation. Symbolref indicates failure action/destination
  OP_UnsignedOverflowCHK, // UnsignedOverflow check. child 1 is the operation
                          // node(add, mul, sub). Child 2 and child 3 are the
  // operands of the operation of the operation. Symbolref
  // indicates failure action/destination
  OP_BNDCHK, // Array bounds check, checks that child 1 > child 2 >= 0 (child 1
             // is
  // bound, 2 is index). Symbolref indicates failure action/destination
  OP_ArrayCopyBNDCHK,    // Array copy bounds check, checks that child 1 >=
                         // child 2.
                         // Symbolref indicates failure action/destination
  OP_BNDCHKwithSpineCHK, // Array bounds check and spine check
  OP_SpineCHK,           // Check if the base array has a spine
  OP_ArrayStoreCHK,      // Array store check. child 1 is object, 2 is array.
                         // Symbolref
                         // indicates failure action/destination
  OP_ArrayCHK,  // Array compatibility check. child 1 is object1, 2 is object2.
                // Symbolref indicates failure action/destination
  OP_Ret,       // Used by ilGen only
  OP_arraycopy, // Call to System.arraycopy that may be partially inlined
  OP_arrayset,  // Inline code for memory initialization of part of an array
  OP_arraytranslate, // Inline code for translation of part of an array to
                     // another
                     // form via lookup
  OP_arraytranslateAndTest, // Inline code for scanning of part of an array for
                            // a
                            // particular 8-bit character
  OP_long2String,           // Convert integer/long value to String
  OP_bitOpMem,        // bit operations (AND, OR, XOR) for memory to memory
  OP_bitOpMemND,      // 3 operand(source1,source2,target) version of bitOpMem
  OP_arraycmp,        // Inline code for memory comparison of part of an array
  OP_arraycmpWithPad, // memory comparison when src1 length != src2 length and
                      // padding is needed
  OP_allocationFence, // Internal fence guarding escape of newObject & final
                      // fields
                      // - eliminatable
  OP_loadFence,       // JEP171: prohibits loadLoad and loadStore reordering (on
                      // globals)
  OP_storeFence, // JEP171: prohibits loadStore and storeStore reordering (on
                 // globals)
  OP_fullFence,  // JEP171: prohibits loadLoad, loadStore, storeLoad, and
                 // storeStore
                 // reordering (on globals)
  OP_MergeNew,   // Parent for New etc. nodes that can all be allocated together
  OP_computeCC,  // compute Condition Codes
  OP_butest, // zEmulator: mask unsigned byte (UInt8) and set condition codes
  OP_sutest, // zEmulator: mask unsigned short (UInt16) and set condition codes

  OP_bucmp, // Currently only valid for zEmulator. Based on the ordering of the
            // two
  // children set the return value:
  OP_bcmp,  //    0 : child1 == child2
  OP_sucmp, //    1 : child1 < child2
  OP_scmp,  //    2 : child1 > child2
  OP_iucmp, //
  OP_icmp,  //
  OP_lucmp, //

  OP_ificmpo,  // integer compare and branch if overflow
  OP_ificmpno, // integer compare and branch if not overflow
  OP_iflcmpo,  // long compare and branch if overflow
  OP_iflcmpno, // long compare and branch if not overflow
  OP_ificmno,  // integer compare negative and branch if overflow
  OP_ificmnno, // integer compare negative and branch if not overflow
  OP_iflcmno,  // long compare negative and branch if overflow
  OP_iflcmnno, // long compare negative and branch if not overflow

  OP_iuaddc, // Currently only valid for zEmulator.  Add two unsigned ints with
             // carry
  OP_luaddc, // Add two longs with carry
  OP_iusubb, // Subtract two ints with borrow
  OP_lusubb, // Subtract two longs with borrow

  OP_icmpset, // icmpset(pointer,c,r): compare *pointer with c, if it matches,
              // replace with r.  Returns 0 on match, 1 otherwise
  OP_lcmpset, // the operation is done atomically - return type is int for both
              // [il]cmpset
  OP_bztestnset, // bztestnset(pointer,c): atomically sets *pointer to c and
  // returns the original value of *p (represents Test And Set on Z)

  // the atomic ops.. atomically update the symref.  first child is address,
  // second child is the RHS interestingly, these ops act like loads and stores
  // at the same time
  OP_ibatomicor, //
  OP_isatomicor, //
  OP_iiatomicor, //
  OP_ilatomicor, //

  OP_dexp, // double exponent

  OP_branch, // generic branch --> DEPRECATED use TR::case instead
  OP_igoto,  // indirect goto, branches to the address specified by a child

  OP_bexp,  // signed byte exponent  (raise signed byte to power)
  OP_buexp, // unsigned byte exponent
  OP_sexp,  // short exponent
  OP_cexp,  // unsigned short exponent
  OP_iexp,  // integer exponent
  OP_iuexp, // unsigned integer exponent
  OP_lexp,  // long exponent
  OP_luexp, // unsigned long exponent
  OP_fexp,  // float exponent
  OP_fuexp, // float base to unsigned integral exponent
  OP_duexp, // double base to unsigned integral exponent

  OP_ixfrs, // transfer sign integer
  OP_lxfrs, // transfer sign long
  OP_fxfrs, // transfer sign float
  OP_dxfrs, // transfer sign double

  OP_fint,  // truncate float to int
  OP_dint,  // truncate double to int
  OP_fnint, // round float to nearest int
  OP_dnint, // round double to nearest int

  OP_fsqrt, // square root of float
  OP_dsqrt, // square root of double

  OP_getstack, // returns current value of SP
  OP_dealloca, // resets value of SP

  OP_ishfl,  // int shift logical
  OP_lshfl,  // long shift logical
  OP_iushfl, // unsigned int shift logical
  OP_lushfl, // unsigned long shift logical
  OP_bshfl,  // byte shift logical
  OP_sshfl,  // short shift logical
  OP_bushfl, // unsigned byte shift logical
  OP_sushfl, // unsigned short shift logical

  OP_idoz, // difference or zero

  OP_dcos, // cos of double, returning double
  OP_dsin, // sin of double, returning double
  OP_dtan, // tan of double, returning double

  OP_dcosh, // cos of double, returning double
  OP_dsinh, // sin of double, returning double
  OP_dtanh, // tan of double, returning double

  OP_dacos, // arccos of double, returning double
  OP_dasin, // arcsin of double, returning double
  OP_datan, // arctan of double, returning double

  OP_datan2, // arctan2 of double, returning double

  OP_dlog, // log of double, returning double

  OP_imulover, // (int) overflow predicate of int multiplication

  OP_dfloor,  // floor of double, returning double
  OP_ffloor,  // floor of float, returning float
  OP_dceil,   // ceil of double, returning double
  OP_fceil,   // ceil of float, returning float
  OP_ibranch, // generic indirct branch --> first child is a constant indicating
              // the mask
  OP_mbranch, // generic branch to multiple potential targets
  OP_getpm,   // get program mask
  OP_setpm,   // set program mask
  OP_loadAutoOffset, // loads the offset (from the SP) of an auto

  OP_imax,  // max of 2 or more integers
  OP_iumax, // max of 2 or more unsigned integers
  OP_lmax,  // max of 2 or more longs
  OP_lumax, // max of 2 or more unsigned longs
  OP_fmax,  // max of 2 or more floats
  OP_dmax,  // max of 2 or more doubles

  OP_imin,  // min of 2 or more integers
  OP_iumin, // min of 2 or more unsigned integers
  OP_lmin,  // min of 2 or more longs
  OP_lumin, // min of 2 or more unsigned longs
  OP_fmin,  // min of 2 or more floats
  OP_dmin,  // min of 2 or more doubles

  OP_trt,       // translate and test
  OP_trtSimple, // same as TRT but ignoring the returned source byte address and
                // table entry value

  OP_ihbit,
  OP_ilbit,
  OP_inolz,
  OP_inotz,
  OP_ipopcnt,

  OP_lhbit,
  OP_llbit,
  OP_lnolz,
  OP_lnotz,
  OP_lpopcnt,

  OP_ibyteswap, // swap bytes in an integer

  OP_bbitpermute,
  OP_sbitpermute,
  OP_ibitpermute,
  OP_lbitpermute,

  OP_Prefetch, // Prefetch

};
typedef enum JIT_NodeOpCode JIT_NodeOpCode;

/**
 * Create a Node with no children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode(JIT_NodeOpCode opcode);

/**
 * Create a Node with one child. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode1C(JIT_NodeOpCode opcode, JIT_NodeRef c1);

/**
 * Create a Node with two children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode2C(JIT_NodeOpCode opcode, JIT_NodeRef c1,
                                    JIT_NodeRef c2);

/**
 * Create a Node with three children. The Node gets created in the context of
 * the current Compiler object stored in Thread Context.
 */
extern JIT_NodeRef JIT_CreateNode3C(JIT_NodeOpCode opcode, JIT_NodeRef c1,
                                    JIT_NodeRef c2, JIT_NodeRef c3);

/**
 * If the given node is not a TreeTrop - creates a new TreeTop node
 * and anchors the node in the treetop.
 */
extern JIT_TreeTopRef JIT_GenerateTreeTop(JIT_ILInjectorRef ilinjector,
                                          JIT_NodeRef n);

/* Convert a BlockRef to CFGNodeRef */
extern JIT_CFGNodeRef JIT_BlockAsCFGNode(JIT_BlockRef b);

/**
 * Adds an edge in the control flow graph - note that blocks are CFGNodes so
 * you can convert blocks to CFGNodes by calling JIT_NodeAsCFGNode().
 */
extern void JIT_CFGAddEdge(JIT_ILInjectorRef ilinjector, JIT_CFGNodeRef from,
                           JIT_CFGNodeRef to);

/**
 * Returns the node that is the bottom of the CFG
 */
extern JIT_CFGNodeRef JIT_GetCFGEnd(JIT_ILInjectorRef ilinjector);

/**
 * Creates a temporary value on the stack of required type; returns a
 * SymbolRef that can be used to load/store.
 */
extern JIT_SymbolRef JIT_CreateTemporary(JIT_ILInjectorRef ilinjector,
                                         JIT_Type type);

/**
 * Creates a temporary array value on the stack; the value will be of
 * type JIT_Aggregate. To load or store values, first obtain the symbol's
 * address using JIT_LoadAddress
 */
extern JIT_SymbolRef JIT_CreateLocalByteArray(JIT_ILInjectorRef ilinjector,
                                              uint32_t size);

/**
 * Gets the type of the SymbolRef.
 */
extern JIT_Type JIT_GetSymbolType(JIT_SymbolRef sym);

/**
 * Load value at a temporary
 */
extern JIT_NodeRef JIT_LoadTemporary(JIT_ILInjectorRef ilinjector,
                                     JIT_SymbolRef symbol);

/**
 * Store value to a temporary; the store is created as a TreeTop
 */
extern void JIT_StoreToTemporary(JIT_ILInjectorRef ilinjector,
                                 JIT_SymbolRef symbol, JIT_NodeRef value);

/**
 * Loads the address of a local temporary or array
 */
extern JIT_NodeRef JIT_LoadAddress(JIT_ILInjectorRef ilinjector,
                                   JIT_SymbolRef symbol);

/**
 * Load a value from specific offset within array; note offset must be exact
 * byte offset (presumably suitably aligned)
 */
extern JIT_NodeRef JIT_ArrayLoad(JIT_ILInjectorRef ilinjector,
                                 JIT_NodeRef address, JIT_NodeRef byte_offset,
                                 JIT_Type value_type);
extern JIT_NodeRef JIT_ArrayLoadAt(JIT_ILInjectorRef ilinjector, uint64_t symbolId, JIT_NodeRef basenode,
	int64_t idx, JIT_Type dt);

/**
 * Store a value at specific array offset; note offset must be exact byte
 * offset (presumably suitably aligned)
 */
extern void JIT_ArrayStore(JIT_ILInjectorRef ilinjector, JIT_NodeRef address,
                           JIT_NodeRef byte_offset, JIT_NodeRef valuenode);
extern void JIT_ArrayStoreAt(JIT_ILInjectorRef ilinjector, uint64_t symbolId, JIT_NodeRef basenode,
	int64_t idx, JIT_NodeRef valuenode);

/**
 * Load the specified parameter, slots start at 0.
 */
extern JIT_NodeRef JIT_LoadParameter(JIT_ILInjectorRef ilinjector,
                                     int32_t slot);

/**
 * Convert a value to target type; note that if conversion is not valid then
 * the call will return NULL.
 */
extern JIT_NodeRef JIT_ConvertTo(JIT_ILInjectorRef ilinjector,
                                 JIT_NodeRef value, JIT_Type targetType,
                                 bool needUnsigned);

/**
 * Obtain a symbol for a known function
 */
JIT_SymbolRef JIT_GetFunctionSymbol(JIT_ILInjectorRef ilinjector,
                                    const char *name);

/**
 * Call a function; function must be registered already
 */
extern JIT_NodeRef JIT_Call(JIT_ILInjectorRef ilinjector,
                            const char *functionName, int32_t numArgs, JIT_NodeRef* args);

/**
 * Call a function via a runtime function ptr
 */
extern JIT_NodeRef JIT_IndirectCall(JIT_ILInjectorRef ilinjector,
                                    JIT_NodeRef funcptr, JIT_Type return_type,
                                    int32_t numArgs, JIT_NodeRef *args);

/**
 * Generate unconditional jump to given block; CFG will be updated to add an
 * edge from current block to target block; the jump instruction will be
 * anchored in a TreeTop. The current block will remain as is - caller must
 * update current block.
 */
extern JIT_NodeRef JIT_Goto(JIT_ILInjectorRef ilinjector, JIT_BlockRef block);

/**
 * Generate return instruction; CFG will be updated to add an edge from
 * current block to end of CFG; the return instruction will be anchored in a
 * TreeTop. The current block will remain as is - caller must update current
 * block.
 */
extern JIT_NodeRef JIT_ReturnValue(JIT_ILInjectorRef ilinjector,
                                   JIT_NodeRef value);
extern JIT_NodeRef JIT_ReturnNoValue(JIT_ILInjectorRef ilinjector);

/**
 * If given value != 0 then jump to blockOnNonZero.
 * CFG will be updated to add edge from current block to blockOnNonZero.
 * The current block will not be updated; note that caller must handle
 * false condition.
 *
 * Note that OMR expects a new block to start after this IL. Control
 * falls through to the new block. If you need to provide an alternate
 * destination then you can put a Goto instruction in the new block.
 *
 * You must also manually add a CFG edge from current block to the
 * next block.
 *
 * Suppose current block is b1, and next block is b2.
 * Also suppose that the IfNotZero target block is b10.
 * Aand alternate destination is b13.
 * Then you must do:
 *
 * JIT_IfNotZeroValue(injector, cond, b10);
 * // Create block b2
 * JIT_CFGAddEdge(injector, JIT_BlockAsCFGNode(b1), JIT_BlockAsCFGNode(b2));
 * JIT_SetCurrentBlock(b2);
 * JIT_Goto(injector, b13); // Must be in the new block
 */
extern JIT_NodeRef JIT_IfNotZeroValue(JIT_ILInjectorRef ilinjector,
                                      JIT_NodeRef value,
                                      JIT_BlockRef blockOnNonZero);

/**
 * If given value == 0 then jump to blockOnZero.
 * CFG will be updated to add edge from current block to blockOnZero.
 * The current block will not be updated; note that caller must handle
 * false condition.
 *
 * The same considerations apply as for JIT_IfNotZeroValue() above.
 */
extern JIT_NodeRef JIT_IfZeroValue(JIT_ILInjectorRef ilinjector,
                                   JIT_NodeRef value, JIT_BlockRef blockOnZero);


/**
 * C style switch; CFG will be updated to add edge from current block
 * to each of the case blocks, and the default block.
 */
extern JIT_NodeRef JIT_Switch(JIT_ILInjectorRef ilinjector, JIT_NodeRef expr,
	JIT_BlockRef default_branch, int num_cases, JIT_BlockRef *case_branches, int32_t *case_values);

/**
 * Checks if the symbol is a temporary
 */
extern bool JIT_IsTemporary(JIT_ILInjectorRef ilinjector, JIT_SymbolRef sym);

/**
 * Gets the Opcode for this node
 */
extern JIT_NodeOpCode JIT_GetOpCode(JIT_NodeRef noderef);

/**
 * If the opcode for the node has a symbol reference then
 * gets the symbol reference for the node else returns NULL.
 */
extern JIT_SymbolRef JIT_GetSymbolForNode(JIT_NodeRef noderef);

/**
 * Optimizer hints
 */
extern void JIT_SetMayHaveLoops(JIT_ILInjectorRef ilinjector);
extern void JIT_SetMayHaveNestedLoops(JIT_ILInjectorRef ilinjector);

/**
 * Inform the compiler that the automatic variable had its 
 * address taken, hence the variable should be considered as aliased
 * when calling functions etc.
 */
extern void JIT_SetAutoAddressTaken(JIT_ILInjectorRef ilinjector,
	JIT_SymbolRef symbol);

#ifdef __cplusplus
}
#endif

#endif
